<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>十个 C++ 隐藏特性 - 硬盘在歌唱</title><link rel=icon type=image/png href=favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="1. []运算符的真相 因为a[8]是*(a+8)的同义表达，*(a+8)又等于*(8+a)，所以a[8]可以写成……8[a]。 int a[3] = {0}; 2[a] = 1; 2[a][a] ="><meta property="og:image" content><meta property="og:title" content="十个 C++ 隐藏特性"><meta property="og:description" content="1. []运算符的真相 因为a[8]是*(a+8)的同义表达，*(a+8)又等于*(8+a)，所以a[8]可以写成……8[a]。 int a[3] = {0}; 2[a] = 1; 2[a][a] ="><meta property="og:type" content="article"><meta property="og:url" content="http://disksing.com/cpp-hidden-features/"><meta property="article:section" content="post"><meta property="article:published_time" content="2015-04-11T00:00:00+00:00"><meta property="article:modified_time" content="2015-04-11T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="十个 C++ 隐藏特性"><meta name=twitter:description content="1. []运算符的真相 因为a[8]是*(a+8)的同义表达，*(a+8)又等于*(8+a)，所以a[8]可以写成……8[a]。 int a[3] = {0}; 2[a] = 1; 2[a][a] ="><link href=http://disksing.com/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=http://disksing.com/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css></head><body><div class=content><header><div class=main><a href=http://disksing.com/>硬盘在歌唱</a></div><nav><a href=/>主页</a>
<a href=/post/>文章</a>
<a href=/project/>开源项目</a>
<a href=/about/>关于</a></nav></header><main><article><div class=title><h1 class=title>十个 C++ 隐藏特性</h1><div class=meta>Posted on Apr 11, 2015</div></div><section class=body><h2 id=1-运算符的真相>1. []运算符的真相</h2><p>因为<code>a[8]</code>是<code>*(a+8)</code>的同义表达，<code>*(a+8)</code>又等于<code>*(8+a)</code>，所以<code>a[8]</code>可以写成……<code>8[a]</code>。</p><pre tabindex=0><code>int a[3] = {0};
2[a] = 1;
2[a][a] = 2;
// a = {0,2,1}
</code></pre><h2 id=2-三元运算符的返回值>2. 三元运算符的返回值</h2><p>三元运算:前后的表达式并不要求类型相同，只需要是同一类型种类(category)，最后的返回值是二者中最为通用的类型。</p><pre tabindex=0><code>void foo (int) {}
void foo (double) {}
struct X {
  X (double d = 0.0) {}
};
void foo (X) {}

int main(void) {
  int i = 1;
  foo(i ? 0 : 0.0); // 调用foo(double)
  X x;
  foo(i ? 0.0 : x);  // 调用foo(X)
}
</code></pre><h2 id=3-函数里面可以直接写-url>3. 函数里面可以直接写 URL</h2><pre tabindex=0><code>void foo() {
    http://disksing.com/
    ...
}
</code></pre><p>可以编译过不报错的。好吧，这个其实比较囧。</p><h2 id=4-不用-memset-初始化结构体>4. 不用 memset 初始化结构体</h2><pre tabindex=0><code>struct A {
   int x;
   int y;
};
A a = {0};   // 或者A a = {};
</code></pre><h2 id=5-不用-memset-初始化成员数组>5. 不用 memset 初始化成员数组</h2><pre tabindex=0><code>class A
{
public:
     A():m_a(),m_c(){}
     
     int m_a[10];
     char m_c[10];
};
</code></pre><h2 id=6-规避前置声明>6. 规避前置声明</h2><pre tabindex=0><code>struct global
{
    void main()
    {
        a = 1;
        b();
    }
    int a;
    void b() {}
} singleton;
</code></pre><h2 id=7-三元运算符>7. 三元运算符</h2><p>大部分书上讲三元运算符都是这么用的：</p><pre tabindex=0><code>x = (y &lt; 0) ? -1 : 1;
</code></pre><p>其实左值也可以是<code>?:</code>表达式：</p><pre tabindex=0><code>(a &lt; b ? a : b) = 10;
</code></pre><p>等价于：</p><pre tabindex=0><code>if (a &lt; b)
    a = 10;
else
    b = 10;
</code></pre><p>可以左值右值都是三元运算符：</p><pre tabindex=0><code>(a &lt; b ? a : b) = (y &lt; 0) ? -1 : 1;
</code></pre><p>还可以用来调用函数的：</p><pre tabindex=0><code>void even(int x) {printf(&#34;%d is even.&#34;, x);}
void odd(int x) {printf(&#34;%d is odd.&#34;, x);}
(x%2==0 ? even : odd)(x);
</code></pre><h2 id=8-namespace-可以用当变量用>8. namespace 可以用当变量用</h2><pre tabindex=0><code>namespace fs = boost::filesystem;
fs::path myPath( strPath, fs::native );
</code></pre><p>在超大型的项目中，或者需要在不同的命名空间切换时比较有用。</p><h2 id=9-for-循环中可以定义-struct-或-class>9. for 循环中可以定义 struct 或 class</h2><pre tabindex=0><code>for(struct {int x; int y;} point = {0,0}; ...; ...) {
    ...
}
</code></pre><h2 id=10-函数默认参数的值可以修改>10. 函数默认参数的值可以修改</h2><p>这是因为 C++ 支持用静态变量当参数的默认值(不一定要是 const 的)</p><pre tabindex=0><code>static int d = 1;

int foo(int x = d)
{
     return x * 2;
}

int main() {
     int x = foo(); // x = 2
     d = 2;
     int y = foo(); // y = 4
}
</code></pre></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80>编程语言</a></li></ul></nav></div></article></main><footer><div style=display:flex></div><div class=footer-info>2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-154774927-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script></div></body></html>