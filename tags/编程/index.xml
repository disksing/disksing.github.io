<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 硬盘在歌唱</title><link>http://disksing.com/tags/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 硬盘在歌唱</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Wed, 15 Oct 2025 00:00:00 +0000</lastBuildDate><atom:link href="http://disksing.com/tags/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>从认知心理学看代码可读性</title><link>http://disksing.com/cognitive-code-readability/</link><pubDate>Wed, 15 Oct 2025 00:00:00 +0000</pubDate><guid>http://disksing.com/cognitive-code-readability/</guid><description>最近我发现，讨论代码可读性时，认知心理学提供了一个很好的视角。那些我们熟知的最佳实践背后都有共同的心理学基础。
代码是给人读的，而人脑处理信息的方式是有规律的。理解这些规律，就能明白为什么有些代码读起来轻松，有些代码读起来费劲；就能在面对具体问题时做出更好的判断，而不是机械地遵循教条。
认知负荷理论：理解代码复杂度的本质 认知负荷理论（Cognitive Load Theory）由 John Sweller 在 1980 年代提出，最初用于教学设计。核心观点很简单：人的工作记忆容量有限，当认知负荷超过容量时，学习和理解效率会急剧下降。
三种认知负荷 这个理论把认知负荷分成三种：**内在负荷（Intrinsic Load）**来自问题本身的固有复杂度，**外在负荷（Extraneous Load）**来自信息呈现方式不当带来的额外负担，**相关负荷（Germane Load）**来自构建和强化心智模型的过程。这三种负荷有个总的限制：内在负荷 + 外在负荷 + 相关负荷 ≤ 工作记忆容量。
应用到读代码的场景：内在负荷对应问题本身的复杂度，比如分布式事务的一致性、复杂的业务逻辑；外在负荷对应代码写得烂带来的额外负担，比如糟糕的命名、混乱的结构、不一致的风格；相关负荷对应理解代码的过程，包括理解抽象、建立心智模型、学习领域知识。
外在负荷完全可以消除，且应该尽量消除。这是我们优化代码可读性的主战场。同样的逻辑，写法不同，理解难度可能相差几倍。而相关负荷是&amp;quot;好的&amp;quot;负荷，好代码应该帮助读者高效地建立正确的心智模型。如果外在负荷太高，留给理解真正问题的容量就不够了。所以好代码的目标是最小化外在负荷，优化相关负荷。
为什么我们需要抽象 在读代码这个任务上，内在负荷并不是一成不变的。同样的需求可以有不同的设计，不同的设计带来不同的理解问题的视角。一个好的抽象能让复杂问题变简单，从而降低内在负荷。
举个例子：假设你要管理一堆相互依赖的状态变化，直接去处理这些状态转换会很复杂（高内在负荷）。但如果引入&amp;quot;状态机&amp;quot;这个概念来理解，问题就清晰多了。虽然学习&amp;quot;状态机&amp;quot;需要一些时间（相关负荷），但理解问题本身变简单了（内在负荷降低）。这就是好的抽象的价值：用相关负荷（学习抽象）来换取更低的内在负荷（问题变简单了）。
从代码可读性的角度看，这解释了为什么设计模式有价值。它们提供理解复杂问题的&amp;quot;心智工具&amp;quot;，降低问题的内在复杂度。比如 Observer 模式让&amp;quot;多对多的依赖关系&amp;quot;变得容易理解。领域驱动设计（DDD）的价值也在这里：找到合适的领域抽象，让复杂的业务逻辑从&amp;quot;一团乱麻&amp;quot;变成&amp;quot;清晰的概念组合&amp;quot;。当然，设计模式和DDD还有其他方面的价值，这里只讨论它们对代码可读性的贡献。
理解了内在负荷和相关负荷可以相互转化，我们就能明白什么是好抽象，什么是过度抽象。好抽象是降低的内在负荷大于引入的相关负荷，总认知负荷降低了。而过度抽象恰恰相反：内在负荷没降低，相关负荷却增加了，比如把简单的 5 行代码拆成 3 个函数需要跳来跳去才能理解，为了&amp;quot;可扩展性&amp;quot;引入根本用不到的复杂设计模式，为了避免&amp;quot;可能的&amp;quot;重复搞出过于通用的抽象。
工作记忆容量限制：代码可读性的核心挑战 认知心理学的一个有趣的发现是 Miller&amp;rsquo;s Law（7±2 法则），它告诉我们：人的工作记忆容量有限，一次只能处理 5-9 个信息单元。
这个工作记忆有点像 CPU 的寄存器：容量很小，但处理速度很快。而长期记忆更像硬盘：容量大，但访问速度慢。读代码时，我们主要依赖工作记忆来理解逻辑，如果工作记忆装不下，就得频繁去&amp;quot;硬盘&amp;quot;（长期记忆）里翻找之前看过的内容，效率就低了。
读代码时，我们需要在脑海中记住：变量的值、状态、分支条件、上下文等。如果超过了工作记忆容量，就会忘记前面的内容，需要回头翻看，思维流程被打断，理解效率急剧下降。
这法则可以用来解释许多常见的代码编写规范。
比如一个函数不应该太长。原因很简单：信息太多时，工作记忆不够用，读到后面就忘了前面的内容，需要回头翻看。
再比如为什么要拆分函数，为什么要封装类。它们的作用就是信息压缩，把占用多个工作记忆单元的信息压缩成 1 个信息单元，显著减少工作记忆占用。
命名为什么如此重要？当命名足够准确时，我们只要看到变量名或者函数名就能直接判断它的行为，这样可以做到完全不占用工作记忆。
不要使用过深的嵌套。这是因为在阅读过程中每进入一层嵌套时，外层的信息作为 context 需要保存在工作记忆中，嵌套过深很容易导致工作记忆不够用。而 early return 模式能很好的解决这个问题，它的价值在于：处理完某种情况后立即 return，该分支占用的记忆单元被释放，不用继续记住。
互相调用的函数要放在一起。一方面避免读到调用函数的时候，被调用的函数信息已经因为工作记忆不够用而忘记了；另一方面被调用的函数读完很快就被用掉了，可以安全地从工作记忆中释放掉，快速腾出空间。
其他的还有诸如减少变量的作用域、函数参数列表不要过长、变量的定义和使用不要离太远，都是类似的道理，不多说了。
格式塔理论 格式塔揭示了代码格式的重要性：大脑会自动把零散信息组织成有意义的整体。我们可以利用这个特性来减少工作记忆占用。
比如接近性原则：大脑会自动根据东西的间隔将它们分组。我们在编码代码时相关代码放在一起，用空行分隔不同的逻辑组。效果很明显：
1// 没分组：20 个独立信息单元 2func handleRequest(req Request) { 3 validateAuth(req) 4 validateInput(req) 5 validatePermission(req) 6 user := getUser(req.</description></item></channel></rss>