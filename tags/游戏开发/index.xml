<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>游戏开发 on 硬盘在歌唱</title><link>http://disksing.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/</link><description>Recent content in 游戏开发 on 硬盘在歌唱</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Thu, 09 Apr 2015 00:00:00 +0000</lastBuildDate><atom:link href="http://disksing.com/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Protocol Buffers 在游戏中的应用</title><link>http://disksing.com/pb-on-gamedev/</link><pubDate>Thu, 09 Apr 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/pb-on-gamedev/</guid><description>提要 Protocol Buffers（后简称pb）是 google 提供的一种结构化数据格式。类似于 xml 或 JSON，有独立于语言和平台的特点，常常用来做通信协议。与 xml 或 JSON相比，pb 还有格式更紧凑的优势，并且序列化/反序列效率更高，更容易做协议版本兼容，所以在网络游戏中应用特别广泛，基本可认为是目前的业界标准。
本文主要介绍网络游戏开发中 pb 的应用思路和一些小技巧。
1. 消息通讯/RPC 消息通讯是 pb 的常规应用。主要流程就是定义好一致的消息格式后，发送方生成填充消息数据，序列化后通过网络发送，接收方从网络收到消息后反序列化出消息结构并进行处理。
一个常见的问题是 pb 打包的数据中是不带消息的类型信息的（区别于 xml 的 DOCTYPE），如果同一信道（例如同一 TCP 连接）可能会发送不同的消息，设计通信协议时要考虑对消息类型进行标识。
对于使用 TCP 的游戏，为了方便接收方进行 TCP 分节的重组，一般我们会定义固定格式的包头填入消息长度，只需要把消息包的类型加入包头即可。要注意服务器与客户端的类型保持一致，可以使用一些代码生成工具保证这一点。也可以采用字符串来标识消息类型，向下兼容性更好。消息处理模块可以使用注册的方式运行时绑定，这样就不会有一个大 switch 了。
使用 HTTP 的游戏可以使用 URI 来代替消息类型，不同的消息处理模块监听不同的 URI，实际上每一个 URI 上的消息包就是确定类型的了。当然在 HTTP Header 中添加消息类型也是个不错的主意。
另一种有些山寨的做法是定义一个大的 message，以 optional 的方式包含所有的消息包，实际传送的消息中只有一个字段是非空的，消息接收方使用 HasXxx() 依次进行判断后确定消息类型。
网游中的大部分通信是“请求-回应”模式的，即客户端发送请求，服务器处理完成后返回对应的回应消息，这个模式可以理解为一次远程过程调用（RPC）。pb 对这种模式有一定的支持，只需要把一对请求回应消息定义为 service，protoc 会生成对应的 rpc 接口。当然了生成的数据结构及一些 Stub 离能直接使用的框架还有一段距离，需要开发者自己实现网络消息发送及消息分发。有大量的第三方框架可以使用，比如百度的 sofa-pbrpc，最近（2015 年）google 也开源了自己的 rpc 框架 gRpc，值得关注。
2. 定义数据结构 pb 的 message 结构比较强大，最重要的是可以进行嵌套，有可选字段，还可以定义枚举，再加上其一次定义就能在各种语言及平台上使用的特性，我们可以用 pb 来定义一些服务器客户端都需要使用的数据结构，不仅可以省一定的工作量，还可以降低服务器客户端的沟通成本。</description></item><item><title>游戏国际化的一些建议</title><link>http://disksing.com/game-i18n/</link><pubDate>Wed, 08 Apr 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/game-i18n/</guid><description>随着国内游戏行业的迅速发展以及竞争的加剧，越来越多的游戏产品开始冲出国门，走向世界。对于国内已经成功上线运营的产品，一般来说发布海外产品不会遇到什么技术上的的瓶颈，常常出现的是发布迟缓、bug 频出、版本管理混乱等问题。
本文试图总结游戏国际化的一些经验，主要关于版本管理和文本翻译这两个方面，不讨论跨国运营或部署，不讨论针对不同文化和习惯的本地化等问题。
1. 不要为每个语言版本建立单独分支。 通常项目开始做国际化版本时已经有了一个比较稳定的中文版，开始做国际化版本时为了保证中文版的稳定，常常会新建一个国际化版本分支交给专人去维护，这样一来就掉进了一个大坑。
看起来分支和主干互不影响，能最灵活地应对国际化的特殊需求。实际上主干上开发的新功能最后总是要发布到国际化版本上的，分支上做的修改越多做代码合并的工作量就越大，往往到后来靠一个人就忙不过来了，干脆成立新的项目组独立开发国际化版本——这样无疑是人力资源的极大浪费。
所以合理的做法是不建立分支，开发一个多语言版本的游戏，而不是多个独立的游戏。
2. 尽量不要针对不同地区写特殊代码。 不同语言版本都会有一些特殊的需求，再加上由于设计的问题可能产生某些语言版本上的特殊 bug，在不开分支的情况下，开发人员很容易就掉进了第二个坑：在代码中编写大量针对不同地区的特殊代码。
很显然大量的特殊处理代码会削弱代码的可维护性，特别是多加一个语言版本时需要到打大量补丁，进一步使代码变得混乱不堪。
所以不到万不得已，尽量不要针对不同地区写特殊代码，而是使用统一的机制来解决不同版本的差异性。比如不同地区上线不同的运营活动，选择使用配置文件进行控制就比在代码中写死更恰当；比如 UI 中的文本在某些语言版本中显示不全，与其针对不同语言设置不同的文本框长度，不如统一将文本框拉至合理的长度，当然做成动态改变文本框长度就更好了。
3. 源代码中不能出现汉字或直接用于显示的字符串。 把用于显示的字符串放进统一的字典文件不仅使游戏翻译更简单，也便于策划进行维护，即使不考虑做国际化版本也是很有必要的。只是很多程序员的自控能力比较弱，或者说保持代码可维护的意识比较弱，经常为了一时的快就绕过这个约束，带来不必要的麻烦。
4. 服务器代码或配置中不能出现汉字或直接用于显示的字符串。 游戏中的一些文本其实是服务器生成发往客户端的，例如系统邮件、系统公告等。最佳实践是把服务器做成是语言无关的，服务器发给客户端的是字典 Key，客户端根据自己的语言解析后拼装好文本并显示。
这样一来就不需要针对不同的语言版本打不同的服务器版本了，还可以实现多个语言版本连接同一台服务器。
举例说明，现在我们需要系统公告恭喜玩家Alice晋升至等级排行榜第1名，中文客户端有如下字典配置：NoticeRank -&amp;gt; 恭喜玩家#user晋升至#rankName第#rank名，LevelRank -&amp;gt; 等级排行榜，服务器发给客户端的消息类似于{Message:&amp;quot;NoticeRank&amp;quot;, user:&amp;quot;Alice&amp;quot;, rankName:&amp;quot;#LevelRank&amp;quot;, rank:&amp;quot;1&amp;quot;}，客户端从字典中取出当前语言的文本，再把参数替换进去生成最终显示用的文字。
5. 尽量不要使用带文字的图片。 有时候游戏中为了实现特殊的美术效果，常常把文字直接画在图片资源中，其实这种做法对国际化特别不友好，容易在翻译时遗漏，而且重新制作各种语言的不同图片也增加美术的工作量，还会给资源打包带来一些麻烦，所以建议尽量避免。
如果不得不使用带文字的图片，有以下几点建议供参考：
开发中使用文档记录所有图片中的文字，并与字典文件一齐交给翻译人员，避免遗漏。 注意保留图片源文件，便于快速替换。 体验降级，对品质要求不高的版本可以考虑直接退化成使用系统文字，减少工作量。 一些常见的游戏术语可以退化成统一使用英文。比如表示暴击的 Critical，表示力量的 Str.。 订制资源打包脚本，针对不同的语言版本打包不同资源。 6. 设计结构化的字典配置，减少冗余。 结构化的意思是不同的字典词条有层次上的区别，不同的词条是可以互相引用的。
例如上文提到的系统公告中，NoticeRank 词条就引用了 LevelRank 词条。假如不支持词条互相引用，这个功能就需要恭喜玩家#user晋升至等级排行榜第#rank名，恭喜玩家#user晋升至战斗力排行榜第#rank名，恭喜玩家#user晋升至声望排行榜第#rank名等等多条几乎完全重复的词条。
使用结构化的字典配置至少有 3 点好处。
首先易于维护。考虑一下我们想把公告中的恭喜换成祝贺，非结构化的工作量就大了几倍。再考虑如果把字典拆分成几份交给不同的翻译人员同时翻译，很容易同一术语出现几种不同译法。
其次是更不容易犯错，以前有个项目中角色叫做“英雄”，而实际我们在讨论功能时用的词是“武将”，策划在配置文本时很容易误用，于是游戏中一会儿是“英雄”一会儿是“武将”，特别混乱。如果所有词条都引用同一个 Hero 词条就不存在这个问题了。
第三点就是省钱——通常翻译都是按行或字数收费的。
7. 不要使用 %d、%s 等标识文本中的变量。 很多程序员想当然地让策划使用 %d、%s 来标记变量，生成文本时直接使用 sprintf 函数。这里有个很大的陷阱就是 sprintf 是依赖于参数的次序的。</description></item><item><title>策划总改需求怎么办？</title><link>http://disksing.com/design-change/</link><pubDate>Mon, 16 Mar 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/design-change/</guid><description>这是我最近面试时经常会问的问题。这个问题很开放，并没有标准答案。有趣的就是，从求职者的回答几乎就能分析他对自己在团队中的角色定位。
比如“尽全力做吧，如果实在做不完就向策划说明原因。”——这位很可能是刚毕业的学生，踌躇满志想在工作中证明自己的能力，可是因为自己没有工作经验多少有些没信心。
比如“有时间就做，时间来不及就和策划商量砍掉不必要的修改。”——这位就不是唯唯诺诺的新人姿态了，工作一段时间的人会意识到程序和策划的关系是平等合作而不是指挥和服从，而且有保护项目进度的意识。
比如“同一个功能改一次两次没问题，我不能接受反复修改，特别是来来回回的改！”——这位可能有长久被策划迫害的惨痛经历，倒是在求职面试时能这么回答也是挺直率的。
比如“实现功能时使用设计模式把代码写灵活一些，这样需求变更时改动成本更小。”——听起来很有道理，但是经验丰富的程序都知道再好的设计也是顶不住策划的奇思妙想的……可能这位刚看过《大话设计模式》，想引诱我把话题转向设计模式吧。
这里我想讨论的话题是：面对策划需求的频繁变更，作为程序我们能做什么？也算是我个人针对这个问题的答案吧。
明确好需求后再开工 需求变更的根源是什么呢？是第一次的设计不够好。所以要遏制策划总改需求，最有效的方法就是一次做好，尽量做到没有改进的余地。
通常在一个游戏团队中，策划和程序的技能树是有差异的。策划的发散思维好，程序的逻辑思维更强；策划会考虑更多怎么让游戏好玩、怎么才能更优雅地坑钱，程序会考虑更多功能缺陷、玩法漏洞、边界条件。所以作为程序最好发挥自己的特长，参与进功能的设计和讨论。
当然了现在游戏团队一般的开发模式还是策划出文档-&amp;gt;程序编码这个流程，那我们能做的就是拿到文档后仔细审查设计，遇到不理解的地方立刻与策划沟通。注意这里说的不理解不仅限于功能的具体实现细节，包括设计目的、与其他功能模块的关系、用户体验等都要全盘分析，只有当自己认需求是完善的、无可挑剔了再开始编码。一旦发现有策划没有想清楚的地方，一定要等策划想清楚讨论明白了再做。磨刀不误砍柴工。
举个例子。上周我们策划发给我一个关卡挑战的活动，因为这个活动会发放比较好的道具，所以限定为每天只能挑战 5 次，规则是进入战斗后成功或失败都扣一次次数，若是中途退出战斗则不扣次数。很明显的漏洞就是玩家可以在眼看着要失败的时候选择退出战斗，这样每天定能拿到 5 次奖励，战斗失败的设计就没了意义。这个问题向策划提出后马上做了修改。试想假如我当时直接就按文档做了，以后必定还是要改的。
再举个例子。依旧是上面那个关卡挑战活动，策划还设计了一个活动排行榜的功能，文档上写明了这个排行榜每天凌晨 5 点更新（显示昨天的排名）。我注意到很奇怪的一点就是活动数据并不是每天重置的，不理解 5 点更新排行的意义何在。向策划提出困惑后得到的解释是：这个排行榜并不需要很强的实时性，不做实时更新也能接受，程序实现起来会简单一些。而实际情况是我们的排行榜模块一开始就设计成可以高效的实时刷新，要做每天更新反而更麻烦……最后策划很高兴地赞成改为效果更好的实时更新了，皆大欢喜。试想假如我当时直接就按文档做了，费力不说效果还不好，以后可能还要修改。
达成共识的设计 策划和程序之间经常会出现一个矛盾：策划提出了一个小小的优化，程序却发现实现这个优化要大动干戈，难以短期内保质完成。于是演变成程序觉得策划真麻烦设计好的方案总是乱改，策划质疑程序的能力是不是有问题……
上面已经提过了，再灵活的设计也顶不住策划的奇思妙想，我的体会是对修改最友好的设计并不是一定要灵活，最重要的是策划、服务器程序、客户端程序要在解决问题的模型上达成共识。
以我们游戏开发中的实际案例来说明。游戏中的 PVE 战斗分好几种：副本（关卡依次解锁，可以反复挑战）、经验副本/金钱副本（每天只能挑战 3 次）、爬塔（只能依序挑战）。对于这几个功能，不同的人会用不同的模型分析：
这几个功能都属于 PVE 模块，只是挑战限制和次数限制有所不同，需要在模块内特殊处理。 这几个功能分别是不同的模块，只是恰巧都要打怪而已，应该分别独立实现。 这几个功能分别是不同的模块，它们都包含挑战关卡的过程，应该提炼出关卡模块由这几个模块分别引用。 这几种模型没有显然的对错之分，具体情况具体分析（实际在我们的游戏中使用模型 3 较为合理）。重点是不论选哪种模型所有人都应该形成共同的认知。如果选择模型 1，那么服务器和客户端都使用单独的 PVE 模块来处理这几个功能，策划将所有数据填入单一的 PVE 配置中，引入 PVE 类型来进行标识。如果选择模型 2，那么服务器和客户端都将三种 PVE 挑战完全分开，策划将数据分别填入三份配置中，只是三份配置有一些相同的列是关卡信息。如果选择模型 3，程序这边使用 3 个独立模块分别引用关卡，策划针对 3 个模块分别配置，这 3 份配置再引用关卡配置。
这样一来，大家在相同的语境下讨论问题会更顺畅，需求变更时所有人对工作量的评估是相当的，策划做优化时很自然就会规避大动干戈的方案了。
正如优秀的程序会去审视策划的设计，优秀的策划也会去主动审视程序的实现，以保证大家解决问题的模型是相同的，团队达成共识需要所有人去一起努力。实际上前面说到的排行榜就是一个很好的反例，如果我们让策划了解到程序原本设计的就是实时更新的排行榜，那么一开始每日刷新的方案就不会被提出了。
大刀阔斧地修改 经常看到有的程序在修改代码时选择把旧代码注释掉而不是删除，原因是“万一过几天策划又要求改回来呢？”
我的观点是，如果你不确定以后会不会再改回来，说明你没有理解好需求，你需要与策划沟通。如果策划也不确定以后会不会改回来，那么先不要做，等策划先想清楚。前面说过，避免总改需求最有效的方法就是一次做好，既然第一次失败了没做到最好，那么第二次就更应该确保做到最好了，不可能是“做着试一试”的心态，即使做不到最好，至少也应该保证绝对不可能不如第一版。
一份优秀的代码一定是简洁、直接、有力的，重构代码时一定要有魄力，该删的就删，该调整的结构就果断调整，永远让版本里的代码像新写出来的一样。我曾经的主程关于重构有过一个很形象的比喻：代码仓库就像一间房子，在房间中生活又不加以收拾，必定会越来越杂乱，最后没办法了只好整个推掉重建。爱整洁的人一定会每天打扫卫生，把东西收纳整齐，不要的东西扔掉，要买新家具了重新好好规划一下房间布局，没空间了落了灰了旧家具也得搬搬放到合适的位置，勤劳的人才能安居乐业。
最让人头痛的代码就是那种一眼看上去历经沧桑的、历史气息扑面而来的。试想过几年以后新入职的员工请教某段代码，你是想回答“哦，这段代码对应游戏中的 X 功能”，还是想回答“呃，这段代码大体上对应游戏的 X 功能，因为最初设计时还包含了现在已经废弃的 Y 模块，所以遗留了处理 A 逻辑的代码。去年有一次处理 Z 模块引发的 B 问题时时间太紧特殊处理了一下 C 逻辑，没想到引发了 D 问题所以又用 E 代码做了下适配……现在确实挺复杂，看不懂也没什么的，你可别乱动这块儿!</description></item><item><title>服务器组件之网关</title><link>http://disksing.com/gameserver-gate/</link><pubDate>Wed, 11 Mar 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/gameserver-gate/</guid><description>提要 本文介绍网络游戏服务器中常用的组件：网关。主要讨论网关的作用，与网关相关的服务器架构设计，及我们项目中的具体实现（Go 语言 HTTP）。
网关的作用 1. 维持连接 我第一次接触网关的时候做的是 MMORPG 游戏，当时的服务器架构是分场景的，即每个 game 维护一个或多个游戏场景。而且 MMORPG 一般来说用的是 TCP 长连接做消息通信，于是当玩家从一个场景切进另一个场景时需要断开与前一个服务器的连接，再去连接后一个服务器，这时候如果网络不通畅，常常就掉线了。
引入网关做代理可以很好的解决了这个问题。客户端启动后连接的是网关，网关再去连接场景服务器并转发所有消息包。切换场景时客户端与网关的连接是不断的，由网关负责去连接新的场景，因为网关和游戏服务器通常在同一局域网内，所以掉线的问题大大改善了。
2. 串并转换 网关可以更进一步增加串并转换的功能。网关和每个 game 只维护单一连接，将多个客户端的并发连接转为串行方式发往 game。这样做的好处是客户端切换场景时网关不用重新建立 TCP 连接了，可靠性更高。
另外 game 处理消息的逻辑可以更加简洁，不用处理 I/O 复用，因为所有的消息来自单个 TCP 连接（单网关）或者固定数量的几个 TCP 连接（多网关的情况）。
3. 权限控制 在多进程的网络游戏架构中，game 除了要处理客户端的消息，同时还会处理其他进程的消息，比如账号、GM 工具等。出于安全原因，一定需要把客户端的消息隔离开来加以限制。
一种方法是考虑进程开启后不同的服务监听不同的 ip 和端口，内部使用的服务只绑定内网 ip，从而起到隔离的效果。
我们采用的另一种做法是使用网关来做权限控制，直接将客户端的请求限制在 HTTP 的某个路径下，这样一来所有的服务器进程都只监听单一 ip 和端口，简化了架构设计。
4. 运维方便 游戏服务器经常需要开服、合服，还有硬件故障等原因导致不得不做服务器迁移。如果 game 直接对客户端提供服务，服务发生变更时往往需要客户端退出重新走登录流程。如果使用网关，在服务器内部发生地址变更时只需要保证网关得到更新并发起重连，客户端甚至根本觉察不到。
部署时可以把所有网关绑定至同一个域名，于是客户端连接服务器时通过统一的域名即可，不用关心具体的 game 服务器地址。同时网关可以很轻松地动态增减，也有了简单的网络负载均衡功能。
5. 省钱 增加新的网关进程意味着我们需要购买更多的服务器，怎么会省钱呢？
因为将外网带宽这种比较昂贵的资源集中管理可以使其利用率更高，自然就达到省钱的效果了。
以我们使用的阿里云 ECS 为例，外网带宽作为一种资源单独收费，目前（2015 年 3 月）价格列举如下，其中带主机费用指的是如果使用独立主机（选择最低配置）运行网关来提供网络接入功能对应的价格：
带宽 带宽费用（元/月） 单价（元/M/月） 带主机费用（元/月） 带主机单价（元/M/月） 1M 23 23 55 55 2M 46 23 78 39 3M 71 23.</description></item><item><title>掉落系统</title><link>http://disksing.com/drop-system/</link><pubDate>Sun, 30 Nov 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/drop-system/</guid><description>本文所讨论的掉落系统是一个游戏中的通用模块，不仅局限于打怪时掉落物品，包括抽卡、开宝箱、任务奖励、活动奖励等功能都可以使用。抽象地说，掉落系统是由给定参数按照特定的算法生成一系列可附加在玩家身上的东西的模块。
需求 我先罗列一下整个的需求列表，会比较零乱，随后我们再来抽丝剥茧理清这里面的逻辑关系。
掉落系统可以掉落任何能附加于玩家的物品。包括金币、宝石、经验、英雄经验、道具、英雄、宠物、装备、积分、体力等等。 策划需要控制掉落物品的数值。如金币宝石的数量，道具的 ID、数量，英雄的 Id、等级、星级等。 掉落物品涉及数值可能是固定的，也可能是在一定范围内随机的，也可能是根据公式计算出来的。 一次掉落可能掉落多个物品。掉落的多个物品可能是固定的，也可能是随机的。随机方式有两种：从多个物品中独立随机（针对每个物品判断概率是否命中），从多个物品中权重随机（按照一组物品概率的比例选出一个）。 特殊情况下会改变掉落。例如抽卡连续抽 10 次后提高得到更好卡的概率，打同个副本次数过多后降低产出概率。 使用通用物品 为了解决第 1 点需求，我们可以一份通用物品数据结构，这样就能使用统一的配置来描述各类不同的物品了。关于通用物品及相关的分发模块设计，前一篇博客游戏开发手记：抽象物品已经做了说明，这里不再赘述。
通用物品数值 有了通用物品，策划基本上可以根据需要配置上任何物品了。但有一些特殊情况要特殊处理，也就是物品的数值不一定是固定的。比如开宝箱，可能需要开出的金币有一定的随机效果，在一定的范围内随机；再如战斗产生的经验需要跟玩家的等级挂钩，玩家等级越高，所获取的经验也越高。
我们想把这些复杂性约束在掉落系统内解决，让具体逻辑写起来更简洁，也可以避免后面各个模块都过于复杂产生 bug。所以最后我们的解决方案可能有些复杂，但综合来看是可以接受的。
具体方案就是把通用物品的每一项数值扩展为 4 列（逻辑类型，参数 1，参数 2，参数 3），最后由四列综合计算出一项数值（如物品数量）。计算方式如下：
逻辑类型==固定数值，则数值为 参数1 逻辑类型==范围随机，则数值为 random(min=参数1，max=参数2) 逻辑类型==玩家等级，则数值为 参数1*玩家等级^2+参数2*玩家等级+参数3 逻辑类型==VIP 等级，则数值为 参数1*VIP等级^2+参数2*VIP等级+参数3 &amp;hellip;其他类型 这样一来，基本上可以满足策划任何关于物品数值的需求。
独立随机和权重随机 需求中第 4 点提到了，掉落的过程是从一系列预先配置的物品中选择一项或多项，选择的过程可能是独立随机或权重随机。我们的做法是把随机的过程划分成多个阶段，第一个阶段进行独立随机，第二个阶段进行权重随机，这样一来策划只需要根据自己的需求进行组合配置，程序这边来看逻辑是统一的。
具体地说，一个 dropId 对应多个 DropGroup，每个 DropGroup 都带有一个命中概率。第一阶段我们拿到 dropId 后遍历其对应的所有 DropGroup 并依次检查概率是否命中，命中则被选出。每个 DropGroup 又对应多个 DropDetail，每个 DropDetail 带有对应的 DropItem 和其随机权重。第二阶段我们从上面计算出的每个 DropGroup 中按照权重随机选择一项 DropDetail。
掉落的转换 第 5 点需求掉落的改变可以换个角度来认知，我们把需求理解成：一个 dropId 可能在某些条件下转变为另一个 dropId。比如抽 10 次卡提高得到好卡的概率，可以配置两份掉落，一份对应于低概率，一份对应于高概率，正常情况下掉落低概率，当低概率的次数是整 10 时则转为高概率。</description></item><item><title>抽象物品</title><link>http://disksing.com/abstract-item/</link><pubDate>Tue, 18 Nov 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/abstract-item/</guid><description>抽象物品这个词汇是我为了说明方便生造出来的，用于指代游戏系统中任意可以附加于玩家的东西，比如金币、宝石、经验、道具、英雄、宠物、装备、积分、体力等等，都可以用通用抽象物品接口来替代。其实抽象物品几乎所有游戏项目都在用（至少我接触过的项目都有），只是没人去正经的归纳。
数据结构 这个东西说白了其实就是一个 union，里面包含了可能的各种数值和数据，当然了因为是 unoin 嘛，其中只有一部分会起作用。这里给出我们项目中使用 protocol buffers 定义的数据结构。
1message CommonItem {2 enum Type {3 Property = 1; //数值 4 BagItem = 2; //背包道具 5 Hero = 3; //英雄 6 //... 7 }8 optional int32 type = 1;9 10 message PropertyData {11 enum PropertyKey {12 Gold = 1; //金币 13 Gem = 2; //宝石 14 Exp = 3; //玩家经验 15 //... 16 }17 optional int32 key = 1;18 optional int32 count = 2;19 }20 optional PropertyData propertyData = 2;21 22 message BagItemData {23 optional int32 id = 1;24 optional int32 count = 2;25 }26 optional BagItemData bagItemData = 3;27 28 message HeroData {29 optional int32 id = 1;30 optional int32 level = 2;31 optional int32 star = 3;32 }33 optional HeroData heroData = 4;34}嗯，看上去还是挺复杂的。CommonItem 包含了一个 type 字段指明了该抽象物品的具体类型，后面是各种具体物品携带的数据，可能是玩家的某个属性值，可能是背包、英雄等，注意我们使用了 optional 选项。 当然了，也可以直接记录几个数字，第一个数字代表类型，后面几个数字的意义由类型来决定。也有直接用带分隔符的字符串来表示的。原理上来说都是类似的，我觉得使用 protocol buffers 进行结构化的表示更加直观一些。</description></item><item><title>数据存储</title><link>http://disksing.com/data-saving/</link><pubDate>Tue, 28 Oct 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/data-saving/</guid><description>最近主要忙着功能开发，一时感觉没什么值得分享的。索性就数据存储这个话题聊聊，顺便自己也理一下思路，希望后面做起来能顺利一点，目前我们项目数据存储还完全没做，只是简单的把每个玩家数据单独存一个文件在硬盘上:-)
关于性能 网络游戏的数据存储有其特殊性。游戏是交互性比较强的产品，对系统响应时间的要求特别高，如果在处理逻辑时同步地去进行数据库 IO 是不可接受的。另外玩家在游戏过程中数据变化非常剧烈，也就是说写数据的频率会特别高，如果设计不合理，数据存储是很容易成为系统瓶颈的。
不妨拿 BBS 系统来做一个比较。我们逛 BBS 时大部分时间都是在浏览，相比之下发帖行为是小概率事件。用户花 20 分钟写完一个帖子点击发布按钮，3 秒钟或 10 秒钟后提示发送成功都是完全可以接受的，甚至提示发送失败要求用户重新再发一次也不是什么大问题。所以对于上述 BBS 系统，在用户提交请求时同步去读写数据库是完全可行的。而网络游戏要做的是同时支持数千人以数秒为间隔不停地发贴，要保证响应时间控制在数毫秒内，还要保证发出去的帖其他人能立即看到。
业内的通行做法是将数据库的职能尽量简化，只拿数据库做数据最终的备份仓库来用。即在服务器进程启动时从数据库中加载所有的全局数据，在玩家上线时从数据库中加载玩家的所有数据，之后所有的逻辑操作都在内存中进行，从而避免游戏过程中读写数据库带来的响应过慢。变化的数据以一定的时间间隔（一般为数分钟）异步写入数据库，这样就缓解了数据库写的压力。
很显然，这样一来数据库所需要的功能是如此简单，只需要有 GET 和 SET 两个接口就完全够用。所以选择合适的 NoSQL 数据库来提高数据存取性能也就理所当然了，必要的时候加入 memcache 来提高读数据的速度也是顺理成章的事情了。这也是我们现在完全没有数据库只是存文件也能正常开发功能的原因——说到底读文件和写文件也就是 GET 和 SET 操作嘛，到时候换一下接口就行了。
当然了这套做法是从传统的 MMORPG 演化而来的。现在大量的手游交互性比较弱，实时性不强，用户量小时处理逻辑时直接去读写数据库往往也完全过得去。但是在系统设计阶段就把数据存储的隐患避免掉还是有好处的，万一哪天游戏火了呢？云风的博客上有具体的案例可以参考：谈谈陌陌争霸在数据库方面踩过的坑(排行榜篇)。
关于容灾 丢档可能是游戏服务器程序员永远的噩梦，虽然没亲身经历过，我相信不幸遭遇运营中游戏丢档并处理过数据恢复的程序员心中应该都有不可磨灭的创伤……
就像策划往往不理解为什么写一个 100% 不会崩溃的程序那么难，软件程序员往往也不理解为什么服务器主机会宕掉，硬盘会直接被写废。实际上在硬件工程师看来，电脑硬件不断出各种问题才是正常的吧。嗯我想说的是，我们应该在系统设计时就应该考虑好容灾，尽量降低系统故障带来的损失。
进程崩溃 根据前面的讨论，为了快速响应客户端请求，也为了降低数据库写的压力，变化的数据并没有立即写进数据库，而是以一定的时间间隔存盘。这个取巧的做法其实有很大的问题：我们修改完内存中的数据后就告知客户端操作完成，但这时数据并没有成功落地，如果这时游戏进程异常崩溃就会造成回档，回档的最大时长为存盘间隔（数分钟）。
那么游戏进程能不能不崩溃呢？有可能，但是比较难，因为游戏进程往往复杂并且迭代很疯狂，要 100% 保证不崩我觉得还得看具体的语言和框架。还是那句话，我们尽量在设计阶段就把风险规避掉。
主要思路就是用一个稳定的进程来分担风险。前面提到可以加入 memcache 进程提高读数据的性能，很自然地我们可以利用 memcache 这个稳定的进程来暂存数据。方案是这样的：每台有游戏进程运行的主机上都启一个 memcache 进程并一直运行，读数据时先从 memcache 读，若读取失败再到数据库读取，当玩家数据变化时同步写入 memcache。这样即使游戏进程崩溃，重启后会首先从 memcache 中读出正确的数据。
往 memcache 写数据一般是通过 HTTP 或 socket，会对客户端请求响应速度略有影响，由于两进程在同一主机，一般来说是可以接受的。如果游戏对响应速度特别敏感，可以用共享内存的方式进行进程间通信，前几年在畅游做 MMORPG 就是用的这种方式，只是共享内存并不易实现，程序复杂度比较高。这两种方式没有对错之分，只是需要根据游戏的需求权衡。
主机崩溃 按照之前的设计，游戏进程和 memcache 都在同一主机，一旦主机崩溃难免会造成丢档。这依旧是一个需要权衡的问题。
如果小概率的短时间丢档可以忍受，那么就这样了，做好性能测试将存盘时间尽量缩短点就行。毕竟 linux 是比较稳定的系统，主机崩溃并不是常态。真出了问题等玩家投诉时查日志补偿回去就好了。 如果游戏对响应速度不敏感，那么将 memcache 移至另一主机。暂且认为两台主机同时崩溃的概率可以忽略不计。 如果想两全其美，可以考虑保留原 memcache 的基础上在另一主机上新增一级 memcache。当然这样一来系统就更复杂了，我个人并不推荐。 数据库损坏 游戏数据库硬盘往往使用 RAID 技术，理论上几乎不可能出现损坏。但是就怕碰上天灾人祸，机房自然灾害也好，程序员误操作也好，如果不做好备份一旦出了问题绝对是致命的，直接毁掉一家公司也不是没可能。</description></item><item><title>战斗模块设计</title><link>http://disksing.com/combat-design/</link><pubDate>Wed, 15 Oct 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/combat-design/</guid><description>本文所描述的战斗模块设计方案源自于实际项目（卡牌手游）的需求，可能并不适用于 MMORPG、ARPG 等类型游戏。本文所涉及战斗的基本形态是：从游戏环境中收集战斗所需要的数据，随后在一个独立封闭的环境中进行若干次迭代计算（其间可能会读入玩家的指令输入），最后达成某些条件后分出胜负战斗结束。如果感觉这个描述太抽象，可以参考一下三国志系列的战斗或者 QQ 斗地主 :P
本文重点分析战斗系统在模块这个级别上的设计和取舍，不涉及具体游戏的战斗计算逻辑。
需求分析 项目战斗采用的是自动回合制战斗，即势力双方派出若干角色按照特定的队形排好后依次进行攻击，直到其中一方所有角色都阵亡则战斗过程结束。为了提高战斗的趣味性和策略性，我们加入了手动释放技能作为补充，即玩家可主动选择释放技能的时机（参考刀塔传奇）。
从程序的角度来看，如果战斗过程全自动不需要玩家干预，那么可以用“秒算”的方式来做。也就是直接一个循环瞬间计算出完整的战斗过程，战斗过程保存下来后再慢慢播放。一旦引入玩家的手动操作，秒算就不再凑效了，因为战斗过程的计算会受实际操作的影响。
按照策划的设计，目前游戏中战斗的类型可以分为 3 种。副本（PvE）：由玩家势力和配置的 NPC 势力对战，玩家可以操作技能释放；排位赛（PvP）：由两方玩家事先派出的势力对战，因为玩家不一定在线，所以技能是自动释放的，不再支持手动操作；挑战赛（PvP）：当两方玩家都在线时发起对战，这时双方都可以操作技能释放。其中
副本战斗要求在网络连接不稳定时也能正常进行，需要由客户端进行战斗计算，等到结束后再将结果上传到服务器验证。 排位赛存在玩家不在线的可能，所以是服务器进行“秒算”，并保存战斗录像供之后播放。 挑战赛在服务器计算，在战斗过程中客户端需要同步操作至服务器。 对于第 1 点需求我是存在异议的，为了网络不稳定情况下的体验，导致游戏中最复杂的战斗部分需要服务器和客户端各实现一遍，工作量增加不说，最重要的模块的复杂程度急剧上升，需要同时支持三种模式：
客户端计算，服务器验证。 服务器秒算，客户端播放。 服务器计算，客户端播放过程和读取操作，并实时同步。 此外战斗逻辑本身是非常复杂的，几乎一定会出 bug 并且不容易测试、发现 bug 也不容易重现、重现了也不容易调试和修正，服务器和客户端还要各自实现一遍导致这一系列成本成倍增加。（项目中服务器和客户端编程语言不一致无法共用代码）
战斗模块的设计，重点就在于为这两个棘手的问题提供一个解决方案。
从外部看战斗模块 从外部看战斗模块，就是规划模块的外部接口，划定模块与外部系统的界线。
用极简的视角来看战斗模块，可以认为它就是一个函数，输入是战斗需要的所有数据（包括双方势力的战斗单位布局，每个战斗单位的出手速度、攻防血、技能等属性），输出是战斗结果（胜负情况，可能还包括战斗过程记录）。
战斗模块不关心的是：战斗从哪里触发；战斗结束后要更新哪些数据；战斗势力是玩家还是NPC；战斗能否发生，如玩家是否有足够的体力，玩家等级是否满足副本等级，是否领取了对应的任务等。
战斗模块关心的是：战斗过程的迭代，战斗结果的判定，战斗过程中数据的网络同步（如果需要），战斗过程的展示（客户端）。
特别注意战斗作为一个独立模块不应该有任何外部依赖。例如某单位的攻击力是由配表中的数值加上其等级进行计算，再综合各种加成得出的，那么应当是在战斗模块外部算出最终数值后再交给战斗模块，而不应该由战斗模块去调用外部接口进行计算。这是很自然的，因为我们一定不想由于某张配表变化或者某模块数据结构的调整导致需要修改战斗模块的代码，最后引入 bug 带来不必要的麻烦。
从内部看战斗模块 从内部看战斗模块，也就是制定模块的实现方法，重点是要同时支持3种战斗模式。
思考问题的过程其实特别快，有时候想法的产生来自于直觉没有什么特别的理由，所以这里只介绍最后想出来的方案……
战斗模块从内部划分为这么几个组件：数据，计算，展示（仅客户端），输入。
数据部分是从模块外部传入的，一部分数据会交给计算模块进行迭代（战斗角色的排布和属性等），一部分数据会交给展示组件用于界面展示（双方名字等级等）。 计算组件负责战斗迭代，它的输出是一系列战斗过程。 展示组件接收战斗过程，并在场景中展示出对应的模型、动画、UI。 输入组件负责读取用户输入。 接下来我们看看这些组件如何组合起来满足 3 种战斗模式。
副本：副本战斗完全在客户端运行，计算组件输出的战斗过程发往展示组件，输入组件读取到的操作发往计算组件影响后续迭代。 排位赛：排位赛由服务器秒算，服务器直接计算出所有战斗过程后返回给模块外部存储下来。客户端查看战斗记录时，计算好的战斗过程以数据的形式发往客户端战斗模块，此时客户端的计算组件退化为“播放器”，只需要将服务器生成的战斗过程依次发往展示组件。 竞技场：竞技场模式操作和战斗过程都是通过网络实时同步的。服务器这边：输入由客户端通过网络发送过来，计算出的战斗过程通过网络发往客户端的展示组件。客户端这边：展示组件从网络接收战斗过程，输入组件读取到输入后发往服务器。 战斗过程的记录方式 战斗过程同时用于组件间通信和战斗录像的保存，其数据结构有必要探讨一下。 首先记录方式应该是基于“打谱”而不是“快照”。两者的区别是这样的，打谱类似于“回合 1：A 攻击 B 产生 10 点伤害；回合 2：B 攻击 A 产生 5 点伤害”，而快照类似于“回合 1：A 100 生命 B 90 生命；回合2： A 95 生命 B 90 生命”。基于打谱的原因有二：其一是通常打谱产生数据量要远小于快照，不妨想一下象棋的棋谱，几十分钟的一局对弈用棋谱记下来不过半页纸；其二是基于事件的记录形式更便于展示组件展现过程。</description></item><item><title>服务器运维的几重境界</title><link>http://disksing.com/game-ops/</link><pubDate>Sun, 12 Oct 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/game-ops/</guid><description>这里所说的运维是一个比较宽泛的概念，基本上与游戏本身无关的、程序员（主要针对服务器）又要去做的事情都涵盖在内，包括版本管理、发布部署、集群管理、服务器容灾、服务器扩容、数据备份恢复、监控警报等等。游戏开发这几年，经历过两家公司，算上现在这个总共有 5 个项目，其实远不算见多识广，很多实践方法是听同事讲的或者招聘的时候打听来的。我大体整理了一下游戏运维发展脉络，顺便展望一下今后的趋势。
“虽然我很笨，但是我很勤奋。” 就像愚公移山，最原始的运维靠的是蛮力。愚公的愚主要就体现在做事情太直接，缺乏进一步的思考。
要打版本？新建个目录把代码 check 出来，make 一下就编译好了，再改一下版本号就大功告成。
怎么部署呢？scp 拷贝到生产环境，再运行脚本解压缩重启一下。
要加新服务器？在新机器上安装好游戏运行要用的软件和库，用 vi 修改全局配置文件把新机器加上去，再用 scp 拷贝到每台服务器，最后全重启一遍。
服务器挂了怎么办？有备用的空闲机器就可以直接用了，如果没有还得花时间装软件。当然改全局配置再整体重启是免不了的了。
问题是很显然的吧。运维人员主要在做重复性的工作，服务器需要 24 小时值守。时间久了一定会疲惫的，而且各种手动修改操作很容易误操作带来不可挽回的损失。
“机器能做的事情交给机器去做，但是关键的操作还是得靠人啊！” 到这个阶段开始考虑编写脚本或者引入工具了，目的是为了减少重复性的工作。
打版本使用写好的自动化脚本，要打版本的时候一行命令版本包就出来了。版本号可能在代码库的某个文件里，打版本之前需要手动改一下提交，做的好点的会在脚本里做自去递增。更进一步会用上可持续集成工具（如 jenkins），这样在网页上点一下就能出版本，打版本的事情就可以完全交给非技术人员了。
更新部署这类线上操作还是要交给运维人员来手动做，但是会编写大量的脚本将操作简化。特别是对于服务器集群的批量操作，通常会在集群中选一台主机作为中控机/跳板机，直接在中控机中使用expect + ssh 脚本批量操作远程主机。需要更新的版本和公用配置也可以从中控机上批量分发出去，可以用脚本，也可以用 rsync 进行同步。
引入监控系统监控服务器的运行状态，有异常情况时通过短信电话通知。
通过使用自动化脚本，运维人员大量的日常事务得到了简化。虽然还是要 24 小时待命，可能时不时得半夜起床处理线上问题，但至少不用轮流加夜班，可以每天回家睡觉了。
“我们已经不是两三岁的小孩了。” 运行在服务器上的程序就像没长大的小孩子，一有风吹草动就又哭又闹。运维就像是同时照顾几十个小孩的保姆，一刻不得闲。实际上我们完全可以通过良好的软件设计来提高程序的可用性。可以使用守护进程保证进程宕了之后能自动重新启动，最好能注册为服务在系统重启后也能恢复服务，如果能做到恢复之前的会话状态就更好了。相互之间有交互的进程不要设计成强制要求特定启动顺序，也就是说要有进程之间设计自动重连的机制。数据库要能在故障时自动进行主从库切换。
对运维友好的程序有了一定的自我修复能力，这样一来大部分问题就不再是需要立即着手解决的了，我们终于可以睡个安稳觉了！
注：后面介绍的 3 个工具基本上是我这几天陆续看来的，这里只是做一下介绍和展望，具体实践有待后面继续探索。
“Linux 上装应用也能像苹果 AppStore 一样便捷吗？” 答案是完全可以，我们要用的 工具是 Docker。简单的说，Docker 可以用来把一个程序和这个程序运行所需要的整套环境打包成一个镜像，这个镜像可以被分发到任意一个 Linux 系统中运行，唯一的要求是这个系统中安装了 Docker。
Docker 官方提供了一个镜像发布中心 DockerHub，用户可以自由发布制作好的镜像供他人使用，也有各种软件维护者发布的官方镜像。DockerHub 听起来像是 Docker 平台上的 GitHub，实际上意义远不止于此，我认为其地位应该相当于 Linux 界的 AppStore。
试想我现在想在某台服务器上运行 nginx，我只需要从 DockerHub 下载 nginx 镜像，再 docker run 启动一个容器来运行这个镜像，我不需要规划把 nginx 安装到系统的哪个目录，也不关心这个 nginx 的版本到底依赖于哪个版本的 libc。同样如果我想要一个 apache 服务器，那么我就下载一个 apache 镜像下来运行，完全不用先准备一套 jdk 环境。不同应用之间是完全独立的，即使需要不同的 jdk 版本也不会产生冲突。</description></item><item><title>游戏逻辑模块组织及数据同步</title><link>http://disksing.com/module-sync/</link><pubDate>Sun, 28 Sep 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/module-sync/</guid><description>一个游戏根据功能可以划分为多个不同的模块，如金钱、背包、装备、技能、任务、成就等。按照软件工程的思想，我们希望分而治之单独实现不同的模块，再将这些模块组合在一起成为一份完整的游戏。但现实是残酷的，不同模块之间往往有千丝万缕的联系，比如购买背包物品会需要扣金币、打一个副本会完成任务，完成任务又会奖励金币和物品，金币的增加又导致一个成就达成。于是我们虽然在不同的类或不同的文件中来实现各个模块，却免不了模块间的交叉引用和互相调用，最后混杂不堪，任何一点小修改都可以导致牵一发而动全身。
为了后面说明方便，我们考虑这样一个小型游戏系统：总共有 3 个模块，分别是金钱、背包、任务。购买背包物品需要消耗金币，卖出背包物品可得到金币，金币增加到一定数额后会导致某个任务的状态变为完成，完成任务可获得物品和金币。这 3 个模块的调用关系如图。
首先我们把模块的数据和逻辑分离，借鉴经典的 MVC 模式，数据部分叫作 Model，逻辑部分叫作 Controller。如此一来，游戏功能部分就被划分出来了两个不同的层次，Controller 处于较高的层次上，可以引用一个或者多个 Model。Model 层专心处理数据，对上层无感知。每个 Model 都是完全独立的模块，不引用任何 Controller 或 Model，不依赖于其他任何对象，可以单拿出来进行单元测试。
对于我们的例子，每个模块提供的接口列举如下：
BagModel：获取物品数量，增加物品，扣除物品
MoneyModel：获取金币数量，增加金币，扣除金币
TaskModel：增加任务，删除任务，标记任务为完成
BagController：购买物品，卖出物品
TaskController：完成任务
购买或卖出物品时，由 BagController 进行或操作校验，随后调用 BagModel 和 MoneyModel 完成数据修改。完成任务时，由 TaskController 调用各个模块。
现在唯一的问题是，既然 MoneyModel 不引用其他模块，那么在金币增加时如何告知任务模块去完成任务呢？这里我们需要引入一个管理依赖的利器：观察者模式。
具体使用方式是把 Model 实现为一个 Subject，对某个 Model 的数据变化感兴趣的 Controller 实现为对应的 Observer。我们的例子中，MoneyModel 是 Subject，在金币数量变化时通知所有已注册的 Observer；TaskController 是 MoneyModel 的一个 Observer，在初始化时向 MoneyModel 注册。
注意图中由 MoneyModel 指向 TaskController 的虚线箭头，代表 MoneyModel 数据变化时会去通知 TaskController，用虚线是因为 MoneyModel 并不依赖于 TaskController（只依赖于 Observer 接口）。同样 BagModel 也可以提供背包物品变化的 Subject，如果新加一个任务是要求某物品的数量达某个值，那么 TaskController 可向 BagModel 注册，这样在物品变化时就能得到通知了，图中也画出了这条虚线。</description></item></channel></rss>