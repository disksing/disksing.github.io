<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>分布式事务的 Commit Point</title>
<link rel=icon href=http://disksing.com/favicon.png><style>:root{--accent:red;--border-width:5px}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-lite-webfont@1.1.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-tc-webfont@1.0.0/style.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/lxgw-wenkai-screen-webfont@1.1.0/style.css><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css integrity=sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u crossorigin=anonymous><link rel=stylesheet href=https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css integrity=sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN crossorigin=anonymous><link rel=stylesheet href=/css/main.css><style>body{font-family:lxgw wenkai lite,sans-serif}pre,code{font-family:lxgw wenkai mono,sans-serif}</style><script src=https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js></script><script src=https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js integrity=sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa crossorigin=anonymous></script><script>$(document).on("click",function(){$(".collapse").collapse("hide")})</script><meta name=generator content="Hugo 0.121.1"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-154774927-1"></script><script>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","UA-154774927-1")</script><script type=text/javascript async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script data-ad-client=ca-pub-8963356574249468 async src=https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js></script></head><body><nav class="navbar navbar-default navbar-fixed-top"><div class=container><div class=navbar-header><a class="navbar-brand visible-xs" href=#>分布式事务的 Commit Point</a>
<button class=navbar-toggle data-target=.navbar-collapse data-toggle=collapse>
<span class=icon-bar></span>
<span class=icon-bar></span>
<span class=icon-bar></span></button></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href=/>主页</a></li><li><a href=/post/>文章</a></li><li><a href=/tip/>知识点</a></li><li><a href=/project/>开源项目</a></li><li><a href=/story/>故事</a></li><li><a href=/about/>关于</a></li></ul><ul class="nav navbar-nav navbar-right"><li class=navbar-icon><a href=mailto:i@disksing.com><i class="fa fa-envelope-o"></i></a></li><li class=navbar-icon><a href=https://github.com/disksing/><i class="fa fa-github"></i></a></li><li class=navbar-icon><a href=http://weibo.com/539523448><i class="fa fa-weibo"></i></a></li><li class=navbar-icon><a href="http://shang.qq.com/wpa/qunwpa?idkey=ade2895067e4105ce59e0c56863d650543b4448245f179574c6684fe1cb7b5d5"><i class="fa fa-qq"></i></a></li><li class=navbar-icon><a href=https://space.bilibili.com/2207710><i class="fa fa-tv"></i></a></li><li class=navbar-icon><a href=https://twitter.com/disksing/><i class="fa fa-twitter"></i></a></li></ul></div></div></nav><main><div><h1>分布式事务的 Commit Point</h1><h5>2020-02-22</h5><a href=http://disksing.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93><kbd class=item-tag>数据库</kbd></a>
<a href=http://disksing.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F><kbd class=item-tag>分布式系统</kbd></a>
<a href=http://disksing.com/tags/tidb><kbd class=item-tag>TiDB</kbd></a></div><div align=start class=content><p>要说这个数据库事务啊，讲究的是 <a href=https://en.wikipedia.org/wiki/ACID>ACID</a>。在分布式场景下，这四个没有一个是简单的，今天我们的话题主要涉及到 A(tomic)。</p><h2 id=一分布式环境的复杂性>一、分布式环境的复杂性</h2><p>在单机环境下，实现事务原子性并不复杂。一般的做法是事务提交之前的写入被存放在 <em>预写式日志</em> 中，然后在事务提交时，往磁盘追加一条 <em>提交记录</em>，完成事务的提交。</p><p>所谓 <em>Commit Point</em>，在这个场景下指的是 <em>提交记录</em> 被持久化到磁盘的一瞬间。在此之前，整个事务的写入都是未生效的状态，事务提交可能被回滚或中止（即使客户端已经发送了 <em>Commit</em> 命令，数据库可能在 <em>Commit Point</em> 之前崩溃）；而在 <em>Commit Point</em> 之后，整个事务就被提交成功了（即使由于数据库崩溃没来得及把结果返回给客户端）。</p><p><strong>本质上，<em>Commit Point</em> 通过把事务内的多条 SQL 语句或者说多个对象的更新是否被提交“归约”到一个单点，也就是事务的 <em>提交记录</em>，从而确保了“要么同时提交，要么同时回滚”。</strong></p><p>在分布式事务中，一个事务会同时牵扯到多个节点。这可能是因为事务本身要更新保存在不同节点的多个对象，也可能因为数据和索引保存在不同的节点（Global Index）。如果沿用单机数据库的经验，通过存储引擎中的 <em>提交记录</em> 来照葫芦画瓢，很容易出现原子性被破坏的情况：</p><ul><li>部分节点成功提交，而部分节点由于冲突等原因需要回滚</li><li>部分节点成功提交，部分节点由于网络中断或崩溃无法提交</li><li>客户端与部分节点网络中断</li><li>客户端在向部分节点发送请求后崩溃</li></ul><h2 id=二两阶段提交>二、两阶段提交</h2><p>两阶段提交（2PC）引入了 <em>协调者（coordinator）</em> 的角色，它通常以库的形式嵌入在发起事务的进程中，也可以以单独的进程或服务存在——这种情况下通常被称为 <em>事务管理器（transaction manager）</em>。同时我们把持有数据的存储节点称为 <em>参与者（participant）</em>。</p><figure style=text-align:center><img src=/assets/img/txn-commit-point-1.png><figcaption align=center><h6>两阶段提交（来源：设计数据密集型应用）</h6></figcaption></figure><p>所谓两阶段，是 <em>协调者</em> 在提交的过程中，分两个步骤分别与 <em>参与者</em> 交互：</p><ol><li>发送 <em>准备（prepare）</em> 请求给所有 <em>参与者</em> ，询问是否可能提交。</li><li>如果所有 <em>参与者</em> 都回复<code>YES</code>，则发起第 2 阶段的 <em>提交（commit）</em> 真正提交；如果任意一个 <em>参与者</em> 回复<code>NO</code>或者超时无响应，则第 2 阶段改为 <em>中止（abort）</em> 回滚之前的操作。</li></ol><p>这个过程类似西方婚礼时的流程。神父在第一阶段询问新娘和新郎是否要结婚，如果新娘和新郎都回复<code>YES</code>，神父才进入第二阶段，宣布二人结为夫妻。如果任意一个人说<code>NO</code>，结婚就中止了。</p><p>很显然，这个流程能防止“部分节点由于冲突等原因需要回滚”，但是并不能防住由于崩溃或者网络中断导致的不同步。好比神父在宣布二人结为夫妻时，新郎由于心情激动晕倒了没有听到，他醒来以后结婚还是未完成的状态，原子性就这样被破坏了。</p><p>解决这种“不同步”的关键正是 <em>Commit Point</em>，正如前面所说，我们需要把多个对象的更新归约到一个单点。实践中，<em>Commit Point</em> 可以有多种选择，下面我们来逐一分析：</p><h3 id=方案一_协调者_-写入-_提交记录_-时为-_commit-point_>方案一：<em>协调者</em> 写入 <em>提交记录</em> 时为 <em>Commit Point</em></h3><p>这是很自然的想法：既然事务的的流程由单一的 <em>协调者</em> 控制的，那么直接把单机的 <em>提交记录</em> 引入 <em>协调者</em> 就可以了。<em>协调者</em> 在发起第二阶段 <em>提交</em> 之前，先在本地记录一份 <em>提交记录</em>，<em>提交记录</em> 被持久化标志着整个事务提交成功，即 <em>Commit Point</em>。</p><p>对于 <em>参与者</em> 来说，当其在第一阶段回复<code>YES</code>后，就进入了 <em>存疑（uncertain）</em> 状态，直到收到 <em>协调者</em> 发来的第二阶段请求。在 <em>存疑</em> 状态时，整个事务可能提交了也可能没有提交（由 <em>Commit Point</em> 决定），也有可能事务已经被 abort。</p><p>回到婚礼的情景。这个方法就相当于神父在宣布结果之前，先记在一个小本本上，新娘新郎有没有结婚成功，完全以小本本上的记录为准。这个过程中不管是新人一方晕倒了或者是神父晕倒了，甚至大家全都晕倒了，只要小本本还在，所有人都能达成一致意见。</p><p><a href=https://en.wikipedia.org/wiki/X/Open_XA>X/Open XA 事务</a> 就是采用的这种方式。这个方案依赖于可靠的 <em>协调者</em>，需要保证即使发生崩溃也要能恢复服务并且不丢失数据，因此往往会做成独立的高可用的 <em>事务管理器</em> 服务，形成集群的单点。</p><h3 id=方案二所有-_参与者_-完成第一阶段时为-_commit-point_>方案二：所有 <em>参与者</em> 完成第一阶段时为 <em>Commit Point</em></h3><p>这是一个“去中心化”的思路，想法是这样的：在依赖 <em>协调者</em> 写 <em>提交记录</em> 的方案中，当所有 <em>参与者</em> 都回复<code>YES</code>后，只要 <em>协调者</em> 不出意外，总是会写入提交成功的记录，因此 <em>Commit Point</em> 可以往前推，变成“所有 <em>参与者</em> 都回复<code>YES</code>”。</p><p>在婚礼的例子里，这个方法就是说结婚成功与否并不取决于神父或者神父的小本本，而是由新娘新郎是否都回答了 <code>YES</code> 唯一决定。只要两人都记得当时自己回答了什么并且不撒谎，不管婚礼现场发生了什么意外，事后大家把两人找出来重新问一下就可以了。</p><p>据不可靠消息 OceanBase 采用的正是这种方式。此方案的优点是延迟最小，因为不需要等待 <em>协调者</em> 持久化 <em>提交记录</em> ，但是当发生异常时恢复成本比较高，因为需要询问所有的 <em>参与者</em>。另一个设计上的关键点在于由谁来维护事务的 <em>参与者</em> 列表：如果由 <em>协调者</em> 来负责，与前一种方案类似，必须要确保 <em>协调者</em> 的可靠性；也可以把列表在第一阶段同步给所有的 <em>参与者</em>，这时付出的代价是增加了 <em>参与者</em> 要持久化的数据量。</p><h3 id=方案三某一特殊-_参与者_-完成第二阶段时为-_commit-point_>方案三：某一特殊 <em>参与者</em> 完成第二阶段时为 <em>Commit Point</em></h3><p>最后一种方法是从 <em>参与者</em> 中选出一个来作为 <em>Primary</em>，在提交的第二阶段 <em>协调者</em> 会先把请求发给 <em>Primary</em>，以 Primary 提交成功作为整个事务的 <em>Commit Point</em>。相比于第一个方案，这个方法也有“去中心化”的效果，不过 <em>Commit Point</em> 往后推迟了。</p><p>还是回到婚礼。婚礼之前，大家商量好了结果以新娘（<em>Primary</em>）是否收到神父的宣告为准，如果出现任何异常，只要新郎记得 <em>Primary</em> 是新娘，到时候直接去问新娘就行。</p><p>TiDB 采用的就是这个方式。这个方案的优点是去中心化，不需要考虑 <em>协调者</em> 的可靠性，而且带给 <em>参与者</em> 的附带成本较低（只用记录 <em>Primary</em> 而不是所有 <em>参与者</em> ）。缺点就是延迟在三个方案中是最高的。</p><h2 id=三处理-_存疑_-状态>三、处理 <em>存疑</em> 状态</h2><p>最后我们讨论 2 个关于 <em>存疑</em> 状态的小问题。</p><h3 id=1-恢复中断的事务>1. 恢复中断的事务</h3><p>如前所述，当 <em>参与者</em> 回复第一阶段消息后就进入 <em>存疑</em> 状态，直到收到第二阶段的消息为止。在此期间由于无法知道事务提交成功还是失败，事务涉及的数据会进入 block 状态无法响应读写。因此不论 <em>Commit Point</em> 如何选择，都必须要考虑中断的事务怎么恢复。</p><figure style=text-align:center><img src=/assets/img/txn-commit-point-2.png><figcaption align=center><h6>协调者崩溃（来源：设计数据密集型应用）</h6></figcaption></figure><p>对于方案 1，因为事务的 <em>提交记录</em> 和 <em>参与者</em> 列表都在 <em>协调者</em> 持久化了，很显然应该由 <em>协调者</em> 在恢复后负责恢复。具体地，如果已经写入 <em>提交记录</em> 了，那么应该向所有 <em>参与者</em> 发送 <em>Commit</em> 消息；反之说明还没有过 <em>Commit Point</em>，此时可以选择直接 abort 事务，如果 <em>协调者</em> 保存了完整的事务信息，也可以重新从第一阶段开始两阶段提交，不过要注意这么做需要 <em>参与者</em> 支持接收重复的 <em>准备</em> 请求（幂等性）。</p><p>再看方案 3。由于 <em>协调者</em> 不持久化任何事务状态，中断事务的恢复应该由 <em>参与者</em> 负责。简单地说，处于 <em>存疑</em> 状态的 <em>参与者</em> 可以通过查询 <em>Primary</em> 来获知事务的状态来决定把自身的 <em>存疑</em> 调整为 <em>已提交</em> 或者 <em>已中止</em>。TiDB 中，中断事务的恢复是惰性的 ，<em>参与者</em> 不会主动推进事务，而是当有新事务访问到 <em>存疑</em> 状态的数据时，新事务的 <em>协调者</em> 客串一下原事务的 <em>协调者</em> 来进行恢复。</p><p>至于方案 2 就比较灵活了，既可以使用方案 1 的方式也可以使用方案 3 的方式，取决于 <em>参与者</em> 列表是保存在 <em>协调者</em> 还是 <em>参与者</em>。</p><h3 id=2-应该如何回复客户端>2. 应该如何回复客户端</h3><p>这个是在 TiDB 的开发中遇到的，仅以 TiDB 为例说明，其他的方案应该也会存在类似的问题。</p><p>在 TiDB 的事务模型里，tidb-server 和 tikv-server 分别扮演 <em>协调者</em> 和 <em>参与者</em> ，当 tidb-server 发出 <em>CommitPrimary</em> 请求之后就进入了 <em>存疑</em> 状态，此时如果 tikv-server 崩溃或者与 tidb-server 网络断开，tidb-server 就无从得知事务是否提交了。</p><p>这种情况下，tidb-server 既不能给客户端返回成功（可能 <em>CommitPrimary</em> 并没有被 tikv-server 收到），也不能给客户端返回错误（可能已经过了 <em>Commit Point</em>，但客户端会误认为事务失败）。此时只有两种办法，要么什么也不做等客户端自行超时，要么直接断开客户端的连接。TiDB 的做法是在一段时间内不断重试，寄希望于能恢复与 tikv-server 的连接，如果经过长时间重试仍然无法解除 <em>存疑</em> 状态，最后就会直接断开连接来把 <em>存疑</em> 的状态给传导给客户端。</p><p>值得注意的是，客户端需要处理事务的 <em>存疑</em> 状态，这并不是分布式数据库所特有的问题。即使是单机的 MySQL，也存在“客户端发送 <em>Commit</em> 命令的一瞬间网络断开”的可能，此时客户端同样无从判断服务端的情况从而进入 <em>存疑</em> 状态。</p><hr><p>参考：</p><ul><li><a href=https://legacy.gitbook.com/book/vonng/ddia-cn/details>设计数据密集型应用</a></li></ul></div><hr><b>欢迎加入技术讨论 QQ 群： </b>745157974<h4 class=page-header>Comments</h4><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//disksing.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a><h4 class=page-header>Related</h4><div class=item><h4><a href=/tidb-gateway/>给TiDB（MySQL）写一个代理网关</a></h4><h5>引入数据库网关来优化TiDB Cloud服务运营成本的故事，以及处理MySQL协议的糟心细节</h5><a href=http://disksing.com/tags/tidb><kbd class=item-tag>TiDB</kbd></a>
<a href=http://disksing.com/tags/mysql><kbd class=item-tag>MySQL</kbd></a>
<a href=http://disksing.com/tags/serverless><kbd class=item-tag>serverless</kbd></a></div><div class=item><h4><a href=/dual-datacenter-master-slave/>双中心主从模式</a></h4><h5>2021-09-11</h5><a href=http://disksing.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F><kbd class=item-tag>分布式系统</kbd></a></div><div class=item><h4><a href=/truetime/>TrueTime和原子钟</a></h4><h5>2021-02-10</h5><a href=http://disksing.com/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F><kbd class=item-tag>分布式系统</kbd></a>
<a href=http://disksing.com/tags/tidb><kbd class=item-tag>TiDB</kbd></a></div></main><footer></footer><p class="copyright text-muted">&copy; 2014-2023 ALL RIGHTS RESERVED
|
本站由 <a href=https://gohugo.io>Hugo</a> 和 <a href=https://github.com/calintat/minimal>Minimal</a> 强力驱动
|
<a href=http://disksing.com/post/index.xml target=_blank><i class="fa fa-rss-square"></i>订阅本站文章</a> <a href=http://github.com/disksing/disksing.github.io/issues/new target=_blank><i class="fa fa-bug"></i>反馈问题</a><br>若无特别说明，本站文章采用 <a rel=license href=http://creativecommons.org/licenses/by/4.0/>CC BY 4.0</a> 进行许可，文中涉及代码采用 <a rel=license href=http://creativecommons.org/publicdomain/zero/1.0/>CC0 1.0 Universal</a> 进行许可</p><script>MathJax={tex:{inlineMath:[["$","$"]],displayMath:[["$$","$$"]]},svg:{fontCache:"global"}}</script><script type=text/javascript id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js></script></body></html>