<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>rust on 硬盘在歌唱</title><link>http://disksing.com/tags/rust/</link><description>Recent content in rust on 硬盘在歌唱</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sat, 08 Feb 2020 00:00:00 +0000</lastBuildDate><atom:link href="http://disksing.com/tags/rust/index.xml" rel="self" type="application/rss+xml"/><item><title>五句话理解 Rust 所有权</title><link>http://disksing.com/understanding-rust-ownership/</link><pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate><guid>http://disksing.com/understanding-rust-ownership/</guid><description>先免责声明一下哈，我是 Rust 新手入门，也没研究过 Rust 编译器。本文只是我自己学习 Rust 所有权时的一些思路，或者说对相关概念的一种解释吧，仅供参考，有谬误在所难免，还请指正。
1. 所有权检查在编译期约束变量名如何访问资源。 所有权检查是编译期的静态检查。这意味着它将不会带来任何运行时的开销。但同时需注意编译器通常不会考虑你的程序将怎样运行，而是基于代码结构做出判断，这使得它经常看上去不那么聪明。
比如你依次写两个条件互斥的 if，编译器可不想那么多，直接告诉你不能 move x 两次。
1fn foobar(n: isize,x: Box&amp;lt;i32&amp;gt;){2ifn&amp;gt;1{3lety=x;4}5ifn&amp;lt;1{6letz=x;// error[E0382]: use of moved value: `x` 7}8}甚至你把 move 操作放在循环次数固定为 1 的 for 循环里面，编译器也傻傻看不出来：
1fn foobar(x: Box&amp;lt;i32&amp;gt;){2for_in0..1{3lety=x;// error[E0382]: use of moved value: `x` 4}5}我们常用“变量”这个术语，比如let x = Box::new(1i32)，被称之为“定义值为 1 的变量 x”，这是比较简化和高度抽象的说法，实际情况更接近于“告知编译器，在此处需要在堆上分配长度为 4 字节的内存并按照 32 位 int 初始化为 1，此块源代码我将使用 x 来指代这块内存”。
在这个例子里，那一块在运行时将被分配出来的内存就是资源，而字符串 x 就是变量名。你可以想像编译器在运行过程中，对当前 scope 可见的变量名维护着一个状态表，并针对每行源代码检查这个变量名的使用是否符合它当前的状态。
编译期的约束是作用在变量名上的，而不是那块内存。比如上面的例子中 x 是只读的，并不妨碍我们定义另外一个可写的变量名来写这块内存（let mut y = x），甚至重新定义 x 来为可写的变量名（let mut x = x）。</description></item></channel></rss>