---
title: "分布式事务的 Commit Point"
date: 2020-02-22
tags: ["数据库", "分布式系统", "TiDB"]
description: "理解分布式事务原子性（atomic）的关键所在"
---

要说这个数据库事务啊，讲究的是 [ACID](https://en.wikipedia.org/wiki/ACID)。在分布式场景下，这四个没有一个是简单的，今天我们的话题主要涉及到 A(tomic)。

## 一、分布式环境的复杂性

在单机环境下，实现事务原子性并不复杂。一般的做法是事务提交之前的写入被存放在 _预写式日志_ 中，然后在事务提交时，往磁盘追加一条 _提交记录_，完成事务的提交。

所谓 _Commit Point_，在这个场景下指的是 _提交记录_ 被持久化到磁盘的一瞬间。在此之前，整个事务的写入都是未生效的状态，事务提交可能被回滚或中止（即使客户端已经发送了 _Commit_ 命令，数据库可能在 _Commit Point_ 之前崩溃）；而在 _Commit Point_ 之后，整个事务就被提交成功了（即使由于数据库崩溃没来得及把结果返回给客户端）。

**本质上，_Commit Point_ 通过把事务内的多条 SQL 语句或者说多个对象的更新是否被提交“归约”到一个单点，也就是事务的 _提交记录_，从而确保了“要么同时提交，要么同时回滚”。**

在分布式事务中，一个事务会同时牵扯到多个节点。这可能是因为事务本身要更新保存在不同节点的多个对象，也可能因为数据和索引保存在不同的节点（Global Index）。如果沿用单机数据库的经验，通过存储引擎中的 _提交记录_ 来照葫芦画瓢，很容易出现原子性被破坏的情况：

- 部分节点成功提交，而部分节点由于冲突等原因需要回滚
- 部分节点成功提交，部分节点由于网络中断或崩溃无法提交
- 客户端与部分节点网络中断
- 客户端在向部分节点发送请求后崩溃

## 二、两阶段提交

两阶段提交（2PC）引入了 _协调者（coordinator）_ 的角色，它通常以库的形式嵌入在发起事务的进程中，也可以以单独的进程或服务存在——这种情况下通常被称为 _事务管理器（transaction manager）_。同时我们把持有数据的存储节点称为 _参与者（participant）_。

{{< figure src="/assets/img/txn-commit-point-1.png" title="两阶段提交（来源：设计数据密集型应用）" style="text-align:center" >}}

所谓两阶段，是 _协调者_ 在提交的过程中，分两个步骤分别与 _参与者_ 交互：

1. 发送 _准备（prepare）_ 请求给所有 _参与者_ ，询问是否可能提交。
2. 如果所有 _参与者_ 都回复`YES`，则发起第 2 阶段的 _提交（commit）_ 真正提交；如果任意一个 _参与者_ 回复`NO`或者超时无响应，则第 2 阶段改为 _中止（abort）_ 回滚之前的操作。

这个过程类似西方婚礼时的流程。神父在第一阶段询问新娘和新郎是否要结婚，如果新娘和新郎都回复`YES`，神父才进入第二阶段，宣布二人结为夫妻。如果任意一个人说`NO`，结婚就中止了。

很显然，这个流程能防止“部分节点由于冲突等原因需要回滚”，但是并不能防住由于崩溃或者网络中断导致的不同步。好比神父在宣布二人结为夫妻时，新郎由于心情激动晕倒了没有听到，他醒来以后结婚还是未完成的状态，原子性就这样被破坏了。

解决这种“不同步”的关键正是 _Commit Point_，正如前面所说，我们需要把多个对象的更新归约到一个单点。实践中，_Commit Point_ 可以有多种选择，下面我们来逐一分析：

###  方案一：_协调者_ 写入 _提交记录_ 时为 _Commit Point_

这是很自然的想法：既然事务的的流程由单一的 _协调者_ 控制的，那么直接把单机的 _提交记录_ 引入 _协调者_ 就可以了。_协调者_ 在发起第二阶段 _提交_ 之前，先在本地记录一份 _提交记录_，_提交记录_ 被持久化标志着整个事务提交成功，即 _Commit Point_。

对于 _参与者_ 来说，当其在第一阶段回复`YES`后，就进入了 _存疑（uncertain）_ 状态，直到收到 _协调者_ 发来的第二阶段请求。在 _存疑_ 状态时，整个事务可能提交了也可能没有提交（由 _Commit Point_ 决定），也有可能事务已经被 abort。

回到婚礼的情景。这个方法就相当于神父在宣布结果之前，先记在一个小本本上，新娘新郎有没有结婚成功，完全以小本本上的记录为准。这个过程中不管是新人一方晕倒了或者是神父晕倒了，甚至大家全都晕倒了，只要小本本还在，所有人都能达成一致意见。

[X/Open XA 事务](https://en.wikipedia.org/wiki/X/Open_XA) 就是采用的这种方式。这个方案依赖于可靠的 _协调者_，需要保证即使发生崩溃也要能恢复服务并且不丢失数据，因此往往会做成独立的高可用的 _事务管理器_ 服务，形成集群的单点。

### 方案二：所有 _参与者_ 完成第一阶段时为 _Commit Point_

这是一个“去中心化”的思路，想法是这样的：在依赖 _协调者_ 写 _提交记录_ 的方案中，当所有 _参与者_ 都回复`YES`后，只要 _协调者_ 不出意外，总是会写入提交成功的记录，因此 _Commit Point_ 可以往前推，变成“所有 _参与者_ 都回复`YES`”。

在婚礼的例子里，这个方法就是说结婚成功与否并不取决于神父或者神父的小本本，而是由新娘新郎是否都回答了 `YES` 唯一决定。只要两人都记得当时自己回答了什么并且不撒谎，不管婚礼现场发生了什么意外，事后大家把两人找出来重新问一下就可以了。

据不可靠消息 OceanBase 采用的正是这种方式。此方案的优点是延迟最小，因为不需要等待 _协调者_ 持久化 _提交记录_ ，但是当发生异常时恢复成本比较高，因为需要询问所有的 _参与者_。另一个设计上的关键点在于由谁来维护事务的 _参与者_ 列表：如果由 _协调者_ 来负责，与前一种方案类似，必须要确保 _协调者_ 的可靠性；也可以把列表在第一阶段同步给所有的 _参与者_，这时付出的代价是增加了 _参与者_ 要持久化的数据量。

### 方案三：某一特殊 _参与者_ 完成第二阶段时为 _Commit Point_

最后一种方法是从 _参与者_ 中选出一个来作为 _Primary_，在提交的第二阶段 _协调者_ 会先把请求发给 _Primary_，以 Primary 提交成功作为整个事务的 _Commit Point_。相比于第一个方案，这个方法也有“去中心化”的效果，不过 _Commit Point_ 往后推迟了。

还是回到婚礼。婚礼之前，大家商量好了结果以新娘（_Primary_）是否收到神父的宣告为准，如果出现任何异常，只要新郎记得 _Primary_ 是新娘，到时候直接去问新娘就行。

TiDB 采用的就是这个方式。这个方案的优点是去中心化，不需要考虑 _协调者_ 的可靠性，而且带给 _参与者_ 的附带成本较低（只用记录 _Primary_ 而不是所有 _参与者_ ）。缺点就是延迟在三个方案中是最高的。

## 三、处理 _存疑_ 状态

最后我们讨论 2 个关于 _存疑_ 状态的小问题。

### 1. 恢复中断的事务

如前所述，当 _参与者_ 回复第一阶段消息后就进入 _存疑_ 状态，直到收到第二阶段的消息为止。在此期间由于无法知道事务提交成功还是失败，事务涉及的数据会进入 block 状态无法响应读写。因此不论 _Commit Point_ 如何选择，都必须要考虑中断的事务怎么恢复。

{{< figure src="/assets/img/txn-commit-point-2.png" title="协调者崩溃（来源：设计数据密集型应用）" style="text-align:center" >}}

对于方案 1，因为事务的 _提交记录_ 和 _参与者_ 列表都在 _协调者_ 持久化了，很显然应该由 _协调者_ 在恢复后负责恢复。具体地，如果已经写入 _提交记录_ 了，那么应该向所有 _参与者_ 发送 _Commit_ 消息；反之说明还没有过 _Commit Point_，此时可以选择直接 abort 事务，如果 _协调者_ 保存了完整的事务信息，也可以重新从第一阶段开始两阶段提交，不过要注意这么做需要 _参与者_ 支持接收重复的 _准备_ 请求（幂等性）。

再看方案 3。由于 _协调者_ 不持久化任何事务状态，中断事务的恢复应该由 _参与者_ 负责。简单地说，处于 _存疑_ 状态的 _参与者_ 可以通过查询 _Primary_ 来获知事务的状态来决定把自身的 _存疑_ 调整为 _已提交_ 或者 _已中止_。TiDB 中，中断事务的恢复是惰性的 ，_参与者_ 不会主动推进事务，而是当有新事务访问到 _存疑_ 状态的数据时，新事务的 _协调者_ 客串一下原事务的 _协调者_ 来进行恢复。

至于方案 2 就比较灵活了，既可以使用方案 1 的方式也可以使用方案 3 的方式，取决于 _参与者_ 列表是保存在 _协调者_ 还是 _参与者_。

### 2. 应该如何回复客户端

这个是在 TiDB 的开发中遇到的，仅以 TiDB 为例说明，其他的方案应该也会存在类似的问题。

在 TiDB 的事务模型里，tidb-server 和 tikv-server 分别扮演 _协调者_ 和 _参与者_ ，当 tidb-server 发出 _CommitPrimary_ 请求之后就进入了 _存疑_ 状态，此时如果 tikv-server 崩溃或者与 tidb-server 网络断开，tidb-server 就无从得知事务是否提交了。

这种情况下，tidb-server 既不能给客户端返回成功（可能 _CommitPrimary_ 并没有被 tikv-server 收到），也不能给客户端返回错误（可能已经过了 _Commit Point_，但客户端会误认为事务失败）。此时只有两种办法，要么什么也不做等客户端自行超时，要么直接断开客户端的连接。TiDB 的做法是在一段时间内不断重试，寄希望于能恢复与 tikv-server 的连接，如果经过长时间重试仍然无法解除 _存疑_ 状态，最后就会直接断开连接来把 _存疑_ 的状态给传导给客户端。

值得注意的是，客户端需要处理事务的 _存疑_ 状态，这并不是分布式数据库所特有的问题。即使是单机的 MySQL，也存在“客户端发送 _Commit_ 命令的一瞬间网络断开”的可能，此时客户端同样无从判断服务端的情况从而进入 _存疑_ 状态。

-----

参考：

- [设计数据密集型应用](https://legacy.gitbook.com/book/vonng/ddia-cn/details)