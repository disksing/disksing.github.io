<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>教程 on 硬盘在歌唱</title><link>http://disksing.com/tags/%E6%95%99%E7%A8%8B/</link><description>Recent content in 教程 on 硬盘在歌唱</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Tue, 15 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://disksing.com/tags/%E6%95%99%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>适合程序员的桌面窗口管理方案</title><link>http://disksing.com/desktop-layout/</link><pubDate>Tue, 15 Mar 2022 00:00:00 +0000</pubDate><guid>http://disksing.com/desktop-layout/</guid><description>介绍下我在办公室使用的桌面窗口管理方案。
先说下硬件：我的工作电脑是一台 13 英寸的 Macbook Pro，外接了一个 27 英寸的显示器，使用了一个电脑支架把笔记本架起来了，这样两个显示器差不多是并排的样子。
然后看下我的窗口布局规划，可以会比较特殊一点，不过是经过精心考虑的。
右边的大显示器我按 1:2 分成两列，左边这一列是最大的显示空间，我把它当作“主空间”来使用，一般我在编码状态下会把编辑器放在这个位置，非编码状态下这里通常就是浏览器了。因为本来两个显示器的大小是不一样的，这样进行划分，主空间两侧的空间反而是比较均衡的状态了。显示器和电脑屏幕在桌子上的摆放也是非对称的，当我坐下时，正对着的是这个“主空间”的正中央，这样也避免一个常见问题：两个一样大的显示器对称排布时，正对着的位置恰好是两个显示器中间的缝，于是工作中几乎时刻是扭着头的，时间一长脖子就受不了了。
左边笔记本的屏幕没有做切分，这块空间一般在编码的时候放浏览器看文档资料，或者放个 Terminal 调试，也可以是另一份代码，使用完整的屏幕保证它总是够用的，不至于不得不把窗口拉大然后频繁切换窗口。
大显示器右边的 1/3 被一分为二，这两块空间主要用来放IM软件，包括飞书、Telegram、微信、QQ、Twitter桌面版……IM软件也平铺出来也是为了减少切换窗口，我只需要在干正事的时候时不时瞟一眼就行了，有需要关注的消息时再去处理。必要的时候这个小格也可以临时放一下 Terminal 之类的小窗口。
再说窗口管理软件方面，可能我的搞法比较变态，我也没找到合适的软件，最后使用的方案是 HammerSpoon 一点脚本，HammerSpoon 大体上就是 Mac 版的 AHK，功能是弱了很多，不过在窗口管理这一块还是完全够用的。我的脚本很简单，使用 4 个快捷键，分别把窗口移动到 4 个格子：
1hs.hotkey.bind(&amp;#34;cmd&amp;#34;, &amp;#34;1&amp;#34;, function() 2 local sf = hs.screen.primaryScreen():frame() 3 hs.window.focusedWindow():setFrame(hs.geometry.new(sf.x, sf.y, sf.w*2/3, sf.h)) 4end) 5 6hs.hotkey.bind(&amp;#34;cmd&amp;#34;, &amp;#34;2&amp;#34;, function() 7 hs.window.focusedWindow():setFrame(hs.screen.allScreens()[2]:frame()) 8end) 9 10hs.hotkey.bind(&amp;#34;cmd&amp;#34;, &amp;#34;3&amp;#34;, function() 11 local sf = hs.screen.primaryScreen():frame() 12 hs.window.focusedWindow():setFrame(hs.geometry.new(sf.x+sf.w*2/3, sf.y, sf.w/3, sf.h/2)) 13end) 14 15hs.hotkey.bind(&amp;#34;cmd&amp;#34;, &amp;#34;4&amp;#34;, function() 16 local sf = hs.</description></item><item><title>自动给 Gmail 中 GitHub 的邮件打标签</title><link>http://disksing.com/tag-github-gmail/</link><pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate><guid>http://disksing.com/tag-github-gmail/</guid><description>相信不少人跟我一样，平时是把 Gmail 直接当成 TODO List 来用的。处理 GitHub Issue 或 PR 时也是基于 Gmail 来完成。根据 PR 和 Issue 的不同状态，给邮件打上对应的标签，是为了能在不点开邮件 thread 的情况下就能评估优先级和快速进行一些处理，效果如下：
那么这个是怎么做的呢？我们知道 Gmail 有过滤器的功能可以自动加标签，可惜的是过滤器不支持正则表达式什么的，在 GitHub 邮件这个场景下很容易误判。最后的方法还是祭出了 Google App Script 大法，代码如下：
用法是创建一个 Google App Script 项目，把代码贴进去，然后部署为网络应用并授权，最后再加上触发器定时运行就搞定了。注意触发器别设得太频繁了，15 分钟运行一次就差不多了，太频繁可能会超出配额。具体操作流程可以参考下追踪 GitHub PR review 记录一文。</description></item><item><title>追踪 GitHub PR review 记录</title><link>http://disksing.com/review-recorder/</link><pubDate>Fri, 18 Oct 2019 00:00:00 +0000</pubDate><guid>http://disksing.com/review-recorder/</guid><description>为啥要搞这个 最近公司项目组推行了一个规定：周报里面要把 Review 过的 PR 填上。作为有尊严的程序员，我们肯定是想自动化地来做。可惜试了下 GitHub 的 API 之后发现有几个蛋疼的问题，主要是如果 review 完了没有 comment 直接 approve 的话查不到记录（其实能，但是会很麻烦）。
于是我就想搞个 chrome 插件来统计，有个额外的 bonus 是可以（粗略）统计 review 每个 PR 花的时间，当然了最主要的原因是我没写过 chrome 插件，想玩一玩。
另外一个问题是，我会用多个电脑工作，很自然地需要一个服务器来同步数据，也为了好玩点，我决定把数据给存在 Google Spreadsheet 上。
怎么做的 先说一下 chrome 插件部分，大体上就是判断是 Pull Request 页面后触发一个定时器，每分钟检查一下，如果在 review 就把相关信息 POST 到服务端记条日志。判断在 review 的标准是一分钟内在 /pull/xxx/files 页面有过点击鼠标，或者按键，或者 scroll 操作。另外点击插件 icon 的时候打开一个新 tab 查询 review 统计信息，默认查最近一周的记录（包含当天）。
Spreadsheet 这边就是一空白的表格加两段 Google App Script。doPost 负责接收 review 记录，记在表格里。doGet 负责汇总一段时间内的记录。
手把手安装教程 这个步骤略麻烦，坦率地讲并不是真推荐给你用，更多地是展示一下怎么把 chrome extension + app script + spread sheet 这套前端+后端+数据库的技术栈给跑起来。</description></item><item><title>使用 Docker+Seafile 搭建私有云存储</title><link>http://disksing.com/docker-seafile/</link><pubDate>Sun, 10 May 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/docker-seafile/</guid><description>缘起 现如今各种云存储服务其实挺多的，国外有经典的 DropBox、Google Drive、微软的 OneDrive 等，国内也有可以免费使用的各种云。
那么为什么想要搭建私有云存储呢？主要是本着“自己的数据自己管理”的原则。
其一是防止数据被窃取。这些云存储服务往往是和自己的某些平台账号绑定在一起的，或者至少是跟自己的某个邮箱绑定在一起的（密码重设），一旦平台账号或邮箱被黑客获取，所有的数据就一览无余了。再加之网络上社工库泛滥，很多人喜欢在各种网络服务上使用相同 的密码，往往是某一个账号失窃，所有数据全部暴露。
其二是防止数据被主动泄漏。Google 退出中国事件之后，我们知道运营在国内的产品数据都是对政府公开的，你一定不想把私密照片传到百度云或是 360 云盘上去。而“棱镜门”之后，我们知道诸如 Google 等号称“不作恶”的企业，其数据也是对政府公开的，老大哥时刻盯着你……
其三是防止数据遗失。有些人贪图更便宜的价格或是更大的空间选择不知名的云存储服务，说不定哪天就停止服务了，到时候悔之晚矣。另外貌似诸如百度云如果判定你的视频文件有色情内容，会主动将其清除掉。
这么一看自己搭建私有云存储太有必要性了。至少能保证自己的私人数据与其他互联网账号无关，不被搜索引擎索引，不被政府监视。保证服务器运行并做好数据备份就不会丢失。如果仅在家庭或公司内部使用可以部署在内网，安全系数更高。
Docker 和 Seafile 介绍 Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架或包装系统。
摘自开源中国
Docker 能简化我们的云存储搭建过程，还能使其更安全地运行，更方便的维护。
Seafile 是新一代的开源云存储软件。它提供更丰富的文件同步和管理功能，以及更好的数据隐私保护和群组协作功能。Seafile 支持 Mac、Linux、Windows 三个桌面平台，支持 Android 和 iOS 两个移动平台。
Seafile 是由国内团队开发的国际型项目，目前已有 10 万左右的用户，以欧洲用户为多。典型的机构用户包括比利时的皇家自然科学博物馆，德国的 Wuppertal 气候、能源研究所。
摘自开源中国
开源的云存储软件其实不少，我也先后测试了好几款，最后确认 Seafile 是目前性能最佳、功能较全、安装最方便的。感谢海文互知团队令人钦佩的工作成果！
搭建指南 1. Docker 环境 Docker 运行的基本需求是 Linux x64，内核版本 2.6.32-431 或更高版本。具体请按照你的系统参考官方文档。
本例中我使用的 Docker 版本是 1.6.1，docker version 运行结果如下。</description></item><item><title>GNU make 自动依赖生成</title><link>http://disksing.com/make-auto-dep/</link><pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/make-auto-dep/</guid><description>原文：Auto-Dependency Generation
作者：Paul D.Smith &amp;lt;psmith@gnu.org&amp;gt;
在基于 make 的编译环境中，正确列出 makefile文 件中所有的依赖项，是一个特别重要，却又时常令人沮丧的任务。
本文档将给出一种能让 make 自动生成并维护依赖的有效方法。
这个方法的发明人是 Tom Tromey &amp;lt;tromey@cygnus.com&amp;gt;，我仅在这里提一次。方法的所有权归他；解释不妥之处都由我（Paul D.Smith）负责。
传统的 make depend 方法 使用 GNU make 的 include 简单自动依赖生成 高级自动依赖生成 避免重复执行 make 避免 No rule to make target … 错误 放置输出文件 定义 MAKEDEPEND MAKEDEPEND = /usr/lib/cpp MAKEDEPEND = makedepend MAKEDEPEND = gcc -M 将编译和依赖合在一起 非 C 文件的依赖生成 为了确保在必须的时候一定会编译（且仅在必须的时候才进行编译），所有的 make 程序都必须精确地知晓目标文件的依赖。
手动更新这个列表不仅繁琐，而且很容易出错。任何初具规模的系统，都倾向于提供自动提取信息的工具。可能最常用的工具就是 makedepend 程序，它能读取 c 源码并生成格式化的目标项依赖列表，可以插入或被包含进 makefile 文件中。</description></item></channel></rss>