<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程语言 on 硬盘在歌唱</title><link>http://disksing.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/</link><description>Recent content in 编程语言 on 硬盘在歌唱</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 11 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="http://disksing.com/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/index.xml" rel="self" type="application/rss+xml"/><item><title>Go语言泛型初体验</title><link>http://disksing.com/try-go-generics/</link><pubDate>Fri, 11 Mar 2022 00:00:00 +0000</pubDate><guid>http://disksing.com/try-go-generics/</guid><description>Go1.18rc1 放出来也有一段时间了，我们期待了多年了泛型的支持终于是要实装了，毕竟已经是RC，后面语法应该不会再大动了，所以决定提前来学习一下。
前几年曾经用Go语言移植了C++ STL的迭代器和算法库（disksing/iter），因为当时没有泛型，所以基本上是 interface{} 和 type assertion 满天飞的状态。这次我就用它来学习泛型，试着改个泛型版本出来。在C++里面，迭代器和算法这块可以说是泛型应用的典中典，所以我觉得要是能把它给改完，应该能说明实用程度是足够的了。
先说结论吧，我觉得这一版至少可以打85分。中间确实也遇到一些障碍和小的体验问题，但是瑕不掩瑜，它在“保持简洁”和“提供更完善的功能”间保持了非常好的平衡。几乎不需要了解什么额外的概念和实现原理，就凭着自己对泛型朴素的理解，就能比较顺利地上手了。
最简单的基础用法这里就不多说了，有兴趣的话可以参考下官方blog的那篇文章。这里仅挑我遇到的几个问题分享一下。
自指 有时候我们需要在 interface 中定义与具体类型相关的方法，比如 Copy() 用于复制一个同类型的对象，或者 Next() 用于返回指向下一个位置的迭代器，又或者 Equal() 用来和同类型的对象进行比较。
在 Rust 里面有一个 Self 来解决这个种问题。在 impl 的时候，你的具体类型是啥，就返回啥。
1traitCopyable{2fn copy(&amp;amp;self)-&amp;gt; Self3}在 Go 里面，没有泛型之前，我们一般是这么干的：
1type Copyable interface { 2 Copy() Copyable 3} 不过这不是泛型，只是一个常规的 interface。我们在实现具体 struct 的时候，Copy() 只能返回 Copyable 而不能用具体类型，在使用的时候还需要强转一下。
1type myType struct{} 2 3func (t myType) Copy() Copyable { 4 return myType{} 5} 6 7func main() { 8 x := myType{} 9 y := x.</description></item><item><title>五句话理解 Rust 所有权</title><link>http://disksing.com/understanding-rust-ownership/</link><pubDate>Sat, 08 Feb 2020 00:00:00 +0000</pubDate><guid>http://disksing.com/understanding-rust-ownership/</guid><description>先免责声明一下哈，我是 Rust 新手入门，也没研究过 Rust 编译器。本文只是我自己学习 Rust 所有权时的一些思路，或者说对相关概念的一种解释吧，仅供参考，有谬误在所难免，还请指正。
1. 所有权检查在编译期约束变量名如何访问资源。 所有权检查是编译期的静态检查。这意味着它将不会带来任何运行时的开销。但同时需注意编译器通常不会考虑你的程序将怎样运行，而是基于代码结构做出判断，这使得它经常看上去不那么聪明。
比如你依次写两个条件互斥的 if，编译器可不想那么多，直接告诉你不能 move x 两次。
1fn foobar(n: isize,x: Box&amp;lt;i32&amp;gt;){2ifn&amp;gt;1{3lety=x;4}5ifn&amp;lt;1{6letz=x;// error[E0382]: use of moved value: `x` 7}8}甚至你把 move 操作放在循环次数固定为 1 的 for 循环里面，编译器也傻傻看不出来：
1fn foobar(x: Box&amp;lt;i32&amp;gt;){2for_in0..1{3lety=x;// error[E0382]: use of moved value: `x` 4}5}我们常用“变量”这个术语，比如let x = Box::new(1i32)，被称之为“定义值为 1 的变量 x”，这是比较简化和高度抽象的说法，实际情况更接近于“告知编译器，在此处需要在堆上分配长度为 4 字节的内存并按照 32 位 int 初始化为 1，此块源代码我将使用 x 来指代这块内存”。
在这个例子里，那一块在运行时将被分配出来的内存就是资源，而字符串 x 就是变量名。你可以想像编译器在运行过程中，对当前 scope 可见的变量名维护着一个状态表，并针对每行源代码检查这个变量名的使用是否符合它当前的状态。
编译期的约束是作用在变量名上的，而不是那块内存。比如上面的例子中 x 是只读的，并不妨碍我们定义另外一个可写的变量名来写这块内存（let mut y = x），甚至重新定义 x 来为可写的变量名（let mut x = x）。</description></item><item><title>Go 语言设计模式：单例</title><link>http://disksing.com/go-singleton/</link><pubDate>Sat, 06 Jun 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/go-singleton/</guid><description>老实说，我觉得单例是 23 种设计模式里最没意思的了，甚至都算不上是个模式。但因为 Go 语言有些特立独行的 package 设计，导致 Go 语言中的单例写起来跟其它语言不太一样，所以还是值得一聊的。再加上这个系列已经很久没更新了，算是水一个吧：）
1. 面向对象与全局变量 通常面向对象软件设计方法中对全局变量和全局函数的使用是比较谨慎的，一般认为这二者的使用会破坏对象的封装性，从而容易导致糟糕的设计。
Java 作为一个相对“纯”的面向对象语言直接就废弃了全局变量和全局函数，可实际上它们本质上是不可能被完全消除的。
理想的面向对象世界里一切皆是对象，所有对象都经历“被创建-&amp;gt;与其他对象发生交互-&amp;gt;走向消亡”的过程。可问题是一切皆对象，那一开始由谁来创建他们呢，于是就产生了 class App 里套一个 public static Main() 的诡异现象。
public static 是什么鬼？不就是全局的嘛，只不过访问时前面要加个 ClassName. 而已。ClassName 不是个对象，是类型，隶属于类型系统管辖，任意模块只要 import 进去随便用，和全局的没什么分别。
其实单例模式这么被发明出来的：某些模块从逻辑上来看自成一体，不依赖于系统其它模块，既不能被其它模块包含，也不应被其它模块创建。简而言之，这个模块就应该是个全局变量。可是面向对象中不能再搞全局变量这套了啊！一定要封装啊！高内聚啊！于是用 static 成员来保存这个本来应该是全局的变量，再用 static 成员函数来获取/创建。
这就是我为什么说觉得单例都算不上是个设计模式，因为它并不是在解决软件开发的问题，只是在应付编程语言设计的坑。
基于以上分析，显然 Go 语言在全局变量上的放任态度并不应被认为是倒行逆施，而是没有跟随 Java 们的脚步在错误的道路上越行越远……
按惯例接下来想个案例上代码，我们实现一个全局的计数器，提供增加计数、获取计数两个接口。 Go 语言中封装的边界是 package，首字符为小写的变量都不会暴露至 package 外部，本例中我们使用单独的 package 来实现计数器。注意其中读写锁的使用保证并发环境下计数的准确性。
1package counter 2 3import &amp;#34;sync&amp;#34; 4 5var ( 6 number int 7 mtx sync.RWMutex 8) 9 10func Add(n int) { 11 mtx.</description></item><item><title>十个 C++ 隐藏特性</title><link>http://disksing.com/cpp-hidden-features/</link><pubDate>Sat, 11 Apr 2015 00:00:00 +0000</pubDate><guid>http://disksing.com/cpp-hidden-features/</guid><description>1. []运算符的真相 因为a[8]是*(a+8)的同义表达，*(a+8)又等于*(8+a)，所以a[8]可以写成……8[a]。
int a[3] = {0}; 2[a] = 1; 2[a][a] = 2; // a = {0,2,1} 2. 三元运算符的返回值 三元运算:前后的表达式并不要求类型相同，只需要是同一类型种类(category)，最后的返回值是二者中最为通用的类型。
void foo (int) {} void foo (double) {} struct X { X (double d = 0.0) {} }; void foo (X) {} int main(void) { int i = 1; foo(i ? 0 : 0.0); // 调用foo(double) X x; foo(i ? 0.0 : x); // 调用foo(X) } 3. 函数里面可以直接写 URL void foo() { http://disksing.</description></item><item><title>Go 语言设计模式：组合</title><link>http://disksing.com/go-composite/</link><pubDate>Mon, 17 Nov 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/go-composite/</guid><description>GoF 对组合模式的定义是，将对象组合成树形结构以表示“部分整体”的层次结构，组合模式使得用户对单个对象和组合对象的使用具有一致性。
对于这句话我是有异议的，这里先卖个关子，我们先从实际例子说起。
组合模式的例子大家都见得很多了，比如文件系统（文件/文件夹）、GUI 窗口（Frame/Control）、菜单（菜单/菜单项）等等，我这里也举个菜单的例子，不过不是操作系统里的菜单，是真正的菜单，KFC 的……
姑且把 KFC 里的食物认为是菜单项，一份套餐是菜单。菜单和菜单项有一些公有属性：名字、描述、价格、都能被购买等，所以正如 GoF 所说，我们需要一致性地使用它们。它们的层次结构体现在一个菜单里会包含多个菜单项或菜单，其价格是所有子项的和。嗯，这个例子其实不是很恰当，不能很好的体现菜单包含菜单的情况，所以我多定义了一个“超值午餐”菜单，其中包含若干个套餐。
用代码归纳总结一下，最终我们的调用代码是这样的：
1func main() { 2 menu1 := NewMenu(&amp;#34;培根鸡腿燕麦堡套餐&amp;#34;, &amp;#34;供应时间：09:15--22:44&amp;#34;) 3 menu1.Add(NewMenuItem(&amp;#34;主食&amp;#34;, &amp;#34;培根鸡腿燕麦堡1个&amp;#34;, 11.5)) 4 menu1.Add(NewMenuItem(&amp;#34;小吃&amp;#34;, &amp;#34;玉米沙拉1份&amp;#34;, 5.0)) 5 menu1.Add(NewMenuItem(&amp;#34;饮料&amp;#34;, &amp;#34;九珍果汁饮料1杯&amp;#34;, 6.5)) 6 7 menu2 := NewMenu(&amp;#34;奥尔良烤鸡腿饭套餐&amp;#34;, &amp;#34;供应时间：09:15--22:44&amp;#34;) 8 menu2.Add(NewMenuItem(&amp;#34;主食&amp;#34;, &amp;#34;新奥尔良烤鸡腿饭1份&amp;#34;, 15.0)) 9 menu2.Add(NewMenuItem(&amp;#34;小吃&amp;#34;, &amp;#34;新奥尔良烤翅2块&amp;#34;, 11.0)) 10 menu2.Add(NewMenuItem(&amp;#34;饮料&amp;#34;, &amp;#34;芙蓉荟蔬汤1份&amp;#34;, 4.5)) 11 12 all := NewMenu(&amp;#34;超值午餐&amp;#34;, &amp;#34;周一至周五有售&amp;#34;) 13 all.Add(menu1) 14 all.Add(menu2) 15 16 all.Print() 17} 得到的输出如下：
超值午餐, 周一至周五有售, ￥53.50 ------------------------ 培根鸡腿燕麦堡套餐, 供应时间：09:15--22:44, ￥23.</description></item><item><title>Go 语言设计模式：迭代器</title><link>http://disksing.com/go-iterator/</link><pubDate>Thu, 30 Oct 2014 00:00:00 +0000</pubDate><guid>http://disksing.com/go-iterator/</guid><description>关于 “Go 语言设计模式” 系列 这个系列首先是关于 Go 语言实践的。在项目中实际使用 Go 语言也有段时间了，一个体会就是不论是官方文档、图书还是网络资料，关于 Go 语言惯用法（idiom）的介绍都比较少，基本只能靠看标准库源代码自己琢磨，所以我特别想在这方面有一些收集和总结。
然后这个系列也是关于设计模式的。虽然 Go 语言不是一门面向对象编程语言，但是很多面向对象设计模式所要解决的问题是在程序设计中客观存在的。不管用什么语言，总是要面对和解决这些问题的，只是解决的思路和途径会有所不同。所以我想就以经典的设计模式作为切入点来展开这个系列，毕竟大家对设计模式都很熟悉了，可以避免无中生有想出一些蹩脚的应用场景。
本系列的具体主题会比较灵活，计划主要包括这些方面的话题：
Go 语言惯用法。 设计模式的实现。特别是引入了闭包，协程，DuckType 等语言特性后带来的变化。 设计模式思想的探讨。会有一些吐槽。 不使用迭代器的方案 **首先要指出的是，绝大多数情况下 Go 程序是不需要用迭代器的。**因为内置的 slice 和 map 两种容器都可以通过 range 进行遍历，并且这两种容器在性能方面做了足够的优化。只要没有特殊的需求，通常是直接用这两种容器解决问题。即使不得不写了一个自定义容器，我们几乎总是可以实现一个函数，把所有元素（的引用）拷贝到一个 slice 之后返回，这样调用者又可以直接用 range 进行遍历了。
当然某些特殊场合迭代器还是有用武之地。比如迭代器的 Next() 是个耗时操作，不能一口气拷贝所有元素；再比如某些条件下需要中断遍历。
经典实现 经典实现完全采用面向对象的思路。为了简化问题，下面的例子中容器就是简单的[]int，我们在 main 函数中使用迭代器进行遍历操作并打印取到的值，迭代器的接口设计参考 java。
1package main 2 3import &amp;#34;fmt&amp;#34; 4 5type Ints []int 6 7func (i Ints) Iterator() *Iterator { 8 return &amp;amp;Iterator{ 9 data: i, 10 index: 0, 11 } 12} 13 14type Iterator struct { 15 data Ints 16 index int 17} 18 19func (i *Iterator) HasNext() bool { 20 return i.</description></item></channel></rss>