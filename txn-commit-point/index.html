<!doctype html><html><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><title>分布式事务的 Commit Point - 硬盘在歌唱</title><link rel=icon type=image/png href=favicon.png><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="理解分布式事务原子性（atomic）的关键所在"><meta property="og:image" content><meta property="og:title" content="分布式事务的 Commit Point"><meta property="og:description" content="理解分布式事务原子性（atomic）的关键所在"><meta property="og:type" content="article"><meta property="og:url" content="https://disksing.com/txn-commit-point/"><meta property="article:section" content="post"><meta property="article:published_time" content="2020-02-22T00:00:00+00:00"><meta property="article:modified_time" content="2020-02-22T00:00:00+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="分布式事务的 Commit Point"><meta name=twitter:description content="理解分布式事务原子性（atomic）的关键所在"><script src=https://disksing.com/js/feather.min.js></script>
<link href=https://disksing.com/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet><link rel=stylesheet type=text/css media=screen href=https://disksing.com/css/main.40ca3a860425083862b7ebd55447caec5c4384573f0cb098b8d06a91e8dace2e.css></head><body><div class=content><header><div class=main><a href=https://disksing.com/>硬盘在歌唱</a></div><nav><a href=/>主页</a>
<a href=/post/>文章</a>
<a href=/about/>关于</a></nav></header><main><article><div class=title><h1 class=title>分布式事务的 Commit Point</h1><div class=meta>Posted on Feb 22, 2020</div></div><section class=body><p>要说这个数据库事务啊，讲究的是 <a href=https://en.wikipedia.org/wiki/ACID>ACID</a>。在分布式场景下，这四个没有一个是简单的，今天我们的话题主要涉及到 A(tomic)。</p><h2 id=一分布式环境的复杂性>一、分布式环境的复杂性</h2><p>在单机环境下，实现事务原子性并不复杂。一般的做法是事务提交之前的写入被存放在 <em>预写式日志</em> 中，然后在事务提交时，往磁盘追加一条 <em>提交记录</em>，完成事务的提交。</p><p>所谓 <em>Commit Point</em>，在这个场景下指的是 <em>提交记录</em> 被持久化到磁盘的一瞬间。在此之前，整个事务的写入都是未生效的状态，事务提交可能被回滚或中止（即使客户端已经发送了 <em>Commit</em> 命令，数据库可能在 <em>Commit Point</em> 之前崩溃）；而在 <em>Commit Point</em> 之后，整个事务就被提交成功了（即使由于数据库崩溃没来得及把结果返回给客户端）。</p><p><strong>本质上，<em>Commit Point</em> 通过把事务内的多条 SQL 语句或者说多个对象的更新是否被提交“归约”到一个单点，也就是事务的 <em>提交记录</em>，从而确保了“要么同时提交，要么同时回滚”。</strong></p><p>在分布式事务中，一个事务会同时牵扯到多个节点。这可能是因为事务本身要更新保存在不同节点的多个对象，也可能因为数据和索引保存在不同的节点（Global Index）。如果沿用单机数据库的经验，通过存储引擎中的 <em>提交记录</em> 来照葫芦画瓢，很容易出现原子性被破坏的情况：</p><ul><li>部分节点成功提交，而部分节点由于冲突等原因需要回滚</li><li>部分节点成功提交，部分节点由于网络中断或崩溃无法提交</li><li>客户端与部分节点网络中断</li><li>客户端在向部分节点发送请求后崩溃</li></ul><h2 id=二两阶段提交>二、两阶段提交</h2><p>两阶段提交（2PC）引入了 <em>协调者（coordinator）</em> 的角色，它通常以库的形式嵌入在发起事务的进程中，也可以以单独的进程或服务存在——这种情况下通常被称为 <em>事务管理器（transaction manager）</em>。同时我们把持有数据的存储节点称为 <em>参与者（participant）</em>。</p><figure style=text-align:center><img src=/assets/img/txn-commit-point-1.png><figcaption align=center><span>两阶段提交（来源：设计数据密集型应用）</span></figcaption></figure><p>所谓两阶段，是 <em>协调者</em> 在提交的过程中，分两个步骤分别与 <em>参与者</em> 交互：</p><ol><li>发送 <em>准备（prepare）</em> 请求给所有 <em>参与者</em> ，询问是否可能提交。</li><li>如果所有 <em>参与者</em> 都回复<code>YES</code>，则发起第 2 阶段的 <em>提交（commit）</em> 真正提交；如果任意一个 <em>参与者</em> 回复<code>NO</code>或者超时无响应，则第 2 阶段改为 <em>中止（abort）</em> 回滚之前的操作。</li></ol><p>这个过程类似西方婚礼时的流程。神父在第一阶段询问新娘和新郎是否要结婚，如果新娘和新郎都回复<code>YES</code>，神父才进入第二阶段，宣布二人结为夫妻。如果任意一个人说<code>NO</code>，结婚就中止了。</p><p>很显然，这个流程能防止“部分节点由于冲突等原因需要回滚”，但是并不能防住由于崩溃或者网络中断导致的不同步。好比神父在宣布二人结为夫妻时，新郎由于心情激动晕倒了没有听到，他醒来以后结婚还是未完成的状态，原子性就这样被破坏了。</p><p>解决这种“不同步”的关键正是 <em>Commit Point</em>，正如前面所说，我们需要把多个对象的更新归约到一个单点。实践中，<em>Commit Point</em> 可以有多种选择，下面我们来逐一分析：</p><h3 id=方案一_协调者_-写入-_提交记录_-时为-_commit-point_>方案一：<em>协调者</em> 写入 <em>提交记录</em> 时为 <em>Commit Point</em></h3><p>这是很自然的想法：既然事务的的流程由单一的 <em>协调者</em> 控制的，那么直接把单机的 <em>提交记录</em> 引入 <em>协调者</em> 就可以了。<em>协调者</em> 在发起第二阶段 <em>提交</em> 之前，先在本地记录一份 <em>提交记录</em>，<em>提交记录</em> 被持久化标志着整个事务提交成功，即 <em>Commit Point</em>。</p><p>对于 <em>参与者</em> 来说，当其在第一阶段回复<code>YES</code>后，就进入了 <em>存疑（uncertain）</em> 状态，直到收到 <em>协调者</em> 发来的第二阶段请求。在 <em>存疑</em> 状态时，整个事务可能提交了也可能没有提交（由 <em>Commit Point</em> 决定），也有可能事务已经被 abort。</p><p>回到婚礼的情景。这个方法就相当于神父在宣布结果之前，先记在一个小本本上，新娘新郎有没有结婚成功，完全以小本本上的记录为准。这个过程中不管是新人一方晕倒了或者是神父晕倒了，甚至大家全都晕倒了，只要小本本还在，所有人都能达成一致意见。</p><p><a href=https://en.wikipedia.org/wiki/X/Open_XA>X/Open XA 事务</a> 就是采用的这种方式。这个方案依赖于可靠的 <em>协调者</em>，需要保证即使发生崩溃也要能恢复服务并且不丢失数据，因此往往会做成独立的高可用的 <em>事务管理器</em> 服务，形成集群的单点。</p><h3 id=方案二所有-_参与者_-完成第一阶段时为-_commit-point_>方案二：所有 <em>参与者</em> 完成第一阶段时为 <em>Commit Point</em></h3><p>这是一个“去中心化”的思路，想法是这样的：在依赖 <em>协调者</em> 写 <em>提交记录</em> 的方案中，当所有 <em>参与者</em> 都回复<code>YES</code>后，只要 <em>协调者</em> 不出意外，总是会写入提交成功的记录，因此 <em>Commit Point</em> 可以往前推，变成“所有 <em>参与者</em> 都回复<code>YES</code>”。</p><p>在婚礼的例子里，这个方法就是说结婚成功与否并不取决于神父或者神父的小本本，而是由新娘新郎是否都回答了 <code>YES</code> 唯一决定。只要两人都记得当时自己回答了什么并且不撒谎，不管婚礼现场发生了什么意外，事后大家把两人找出来重新问一下就可以了。</p><p>据不可靠消息 OceanBase 采用的正是这种方式。此方案的优点是延迟最小，因为不需要等待 <em>协调者</em> 持久化 <em>提交记录</em> ，但是当发生异常时恢复成本比较高，因为需要询问所有的 <em>参与者</em>。另一个设计上的关键点在于由谁来维护事务的 <em>参与者</em> 列表：如果由 <em>协调者</em> 来负责，与前一种方案类似，必须要确保 <em>协调者</em> 的可靠性；也可以把列表在第一阶段同步给所有的 <em>参与者</em>，这时付出的代价是增加了 <em>参与者</em> 要持久化的数据量。</p><h3 id=方案三某一特殊-_参与者_-完成第二阶段时为-_commit-point_>方案三：某一特殊 <em>参与者</em> 完成第二阶段时为 <em>Commit Point</em></h3><p>最后一种方法是从 <em>参与者</em> 中选出一个来作为 <em>Primary</em>，在提交的第二阶段 <em>协调者</em> 会先把请求发给 <em>Primary</em>，以 Primary 提交成功作为整个事务的 <em>Commit Point</em>。相比于第一个方案，这个方法也有“去中心化”的效果，不过 <em>Commit Point</em> 往后推迟了。</p><p>还是回到婚礼。婚礼之前，大家商量好了结果以新娘（<em>Primary</em>）是否收到神父的宣告为准，如果出现任何异常，只要新郎记得 <em>Primary</em> 是新娘，到时候直接去问新娘就行。</p><p>TiDB 采用的就是这个方式。这个方案的优点是去中心化，不需要考虑 <em>协调者</em> 的可靠性，而且带给 <em>参与者</em> 的附带成本较低（只用记录 <em>Primary</em> 而不是所有 <em>参与者</em> ）。缺点就是延迟在三个方案中是最高的。</p><h2 id=三处理-_存疑_-状态>三、处理 <em>存疑</em> 状态</h2><p>最后我们讨论 2 个关于 <em>存疑</em> 状态的小问题。</p><h3 id=1-恢复中断的事务>1. 恢复中断的事务</h3><p>如前所述，当 <em>参与者</em> 回复第一阶段消息后就进入 <em>存疑</em> 状态，直到收到第二阶段的消息为止。在此期间由于无法知道事务提交成功还是失败，事务涉及的数据会进入 block 状态无法响应读写。因此不论 <em>Commit Point</em> 如何选择，都必须要考虑中断的事务怎么恢复。</p><figure style=text-align:center><img src=/assets/img/txn-commit-point-2.png><figcaption align=center><span>协调者崩溃（来源：设计数据密集型应用）</span></figcaption></figure><p>对于方案 1，因为事务的 <em>提交记录</em> 和 <em>参与者</em> 列表都在 <em>协调者</em> 持久化了，很显然应该由 <em>协调者</em> 在恢复后负责恢复。具体地，如果已经写入 <em>提交记录</em> 了，那么应该向所有 <em>参与者</em> 发送 <em>Commit</em> 消息；反之说明还没有过 <em>Commit Point</em>，此时可以选择直接 abort 事务，如果 <em>协调者</em> 保存了完整的事务信息，也可以重新从第一阶段开始两阶段提交，不过要注意这么做需要 <em>参与者</em> 支持接收重复的 <em>准备</em> 请求（幂等性）。</p><p>再看方案 3。由于 <em>协调者</em> 不持久化任何事务状态，中断事务的恢复应该由 <em>参与者</em> 负责。简单地说，处于 <em>存疑</em> 状态的 <em>参与者</em> 可以通过查询 <em>Primary</em> 来获知事务的状态来决定把自身的 <em>存疑</em> 调整为 <em>已提交</em> 或者 <em>已中止</em>。TiDB 中，中断事务的恢复是惰性的 ，<em>参与者</em> 不会主动推进事务，而是当有新事务访问到 <em>存疑</em> 状态的数据时，新事务的 <em>协调者</em> 客串一下原事务的 <em>协调者</em> 来进行恢复。</p><p>至于方案 2 就比较灵活了，既可以使用方案 1 的方式也可以使用方案 3 的方式，取决于 <em>参与者</em> 列表是保存在 <em>协调者</em> 还是 <em>参与者</em>。</p><h3 id=2-应该如何回复客户端>2. 应该如何回复客户端</h3><p>这个是在 TiDB 的开发中遇到的，仅以 TiDB 为例说明，其他的方案应该也会存在类似的问题。</p><p>在 TiDB 的事务模型里，tidb-server 和 tikv-server 分别扮演 <em>协调者</em> 和 <em>参与者</em> ，当 tidb-server 发出 <em>CommitPrimary</em> 请求之后就进入了 <em>存疑</em> 状态，此时如果 tikv-server 崩溃或者与 tidb-server 网络断开，tidb-server 就无从得知事务是否提交了。</p><p>这种情况下，tidb-server 既不能给客户端返回成功（可能 <em>CommitPrimary</em> 并没有被 tikv-server 收到），也不能给客户端返回错误（可能已经过了 <em>Commit Point</em>，但客户端会误认为事务失败）。此时只有两种办法，要么什么也不做等客户端自行超时，要么直接断开客户端的连接。TiDB 的做法是在一段时间内不断重试，寄希望于能恢复与 tikv-server 的连接，如果经过长时间重试仍然无法解除 <em>存疑</em> 状态，最后就会直接断开连接来把 <em>存疑</em> 的状态给传导给客户端。</p><p>值得注意的是，客户端需要处理事务的 <em>存疑</em> 状态，这并不是分布式数据库所特有的问题。即使是单机的 MySQL，也存在“客户端发送 <em>Commit</em> 命令的一瞬间网络断开”的可能，此时客户端同样无从判断服务端的情况从而进入 <em>存疑</em> 状态。</p><hr><p>参考：</p><ul><li><a href=https://legacy.gitbook.com/book/vonng/ddia-cn/details>设计数据密集型应用</a></li></ul></section><div class=post-tags><nav class="nav tags"><ul class=tags><li><a href=/tags/%E6%95%B0%E6%8D%AE%E5%BA%93>数据库</a></li><li><a href=/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F>分布式系统</a></li><li><a href=/tags/tidb>TiDB</a></li></ul></nav></div></article></main><footer><div style=display:flex><a class=soc href=https://github.com/disksing/ title=GitHub><i data-feather=github></i></a><a class=soc href=https://github.com/disksing/ title=Twitter><i data-feather=twitter></i></a><a class=soc href=https://space.bilibili.com/2207710 title=Bilibili><i data-feather=tv></i></a></div><div class=footer-info>2022 <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a></div></footer><script type=application/javascript>var doNotTrack=!1;doNotTrack||(window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-154774927-1","auto"),ga("send","pageview"))</script><script async src=https://www.google-analytics.com/analytics.js></script>
<script>feather.replace()</script></div></body></html>